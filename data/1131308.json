{"cf_tracking_thunderbird_esr52": "---", "status": "RESOLVED", "cf_tracking_firefox60": "---", "attachments": [{"creator": "continuation@gmail.com", "is_obsolete": 1, "is_patch": 1, "flags": [], "content_type": "text/plain", "id": 8562955}, {"creator": "n.nethercote@gmail.com", "is_obsolete": 1, "is_patch": 1, "flags": [], "content_type": "text/plain", "id": 8615823}, {"creator": "n.nethercote@gmail.com", "is_obsolete": 1, "is_patch": 1, "flags": [{"status": "+", "name": "feedback", "modification_date": "2015-06-08T17:34:16Z", "type_id": 607, "creation_date": "2015-06-08T17:34:16Z", "id": 1184345, "setter": "nfroyd@mozilla.com"}], "content_type": "text/plain", "id": 8615825}, {"creator": "n.nethercote@gmail.com", "is_obsolete": 1, "is_patch": 1, "flags": [{"status": "+", "name": "review", "modification_date": "2015-06-26T17:31:20Z", "type_id": 4, "creation_date": "2015-06-18T18:54:25Z", "id": 1194628, "setter": "nfroyd@mozilla.com"}], "content_type": "text/plain", "id": 8624396}, {"creator": "n.nethercote@gmail.com", "is_obsolete": 1, "is_patch": 1, "flags": [{"status": "+", "name": "review", "modification_date": "2015-06-30T20:12:43Z", "type_id": 4, "creation_date": "2015-06-18T18:55:16Z", "id": 1194629, "setter": "nfroyd@mozilla.com"}], "content_type": "text/plain", "id": 8624398}, {"creator": "n.nethercote@gmail.com", "is_obsolete": 1, "is_patch": 1, "flags": [{"status": "+", "name": "review", "modification_date": "2015-06-26T17:44:01Z", "type_id": 4, "creation_date": "2015-06-18T18:56:17Z", "id": 1194630, "setter": "nfroyd@mozilla.com"}], "content_type": "text/plain", "id": 8624399}, {"creator": "n.nethercote@gmail.com", "is_obsolete": 0, "is_patch": 1, "flags": [{"status": "+", "name": "review", "modification_date": "2015-07-06T08:51:11Z", "type_id": 4, "creation_date": "2015-07-06T08:51:11Z", "id": 1202275, "setter": "n.nethercote@gmail.com"}], "content_type": "text/plain", "id": 8629841}, {"creator": "n.nethercote@gmail.com", "is_obsolete": 0, "is_patch": 1, "flags": [{"status": "+", "name": "review", "modification_date": "2015-07-06T08:51:19Z", "type_id": 4, "creation_date": "2015-07-06T08:51:19Z", "id": 1202276, "setter": "n.nethercote@gmail.com"}], "content_type": "text/plain", "id": 8629842}], "classification": "Components", "creator": "n.nethercote@gmail.com", "cc": ["bent.mozilla@gmail.com", "continuation@gmail.com", "n.nethercote@gmail.com", "nfroyd@mozilla.com"], "depends_on": [], "creation_time": "2015-02-09T22:24:59Z", "cf_user_story": "", "cf_tracking_firefox_relnote": "---", "platform": "All", "cf_status_firefox58": "---", "cf_status_firefox59": "---", "keywords": [], "summary": "Replace {INCREMENT,DECREMENT}_RECURSION_LEVEL in pldhash.cpp with an RAII class", "id": 1131308, "assigned_to_detail": {"email": "n.nethercote@gmail.com", "id": 334849, "name": "n.nethercote@gmail.com", "real_name": "Nicholas Nethercote [:njn]"}, "severity": "normal", "is_confirmed": true, "is_creator_accessible": true, "cf_has_regression_range": "---", "assigned_to": "n.nethercote@gmail.com", "comment_count": 36, "comments": [{"text": "These macros are horrible. RAII will improve things greatly.", "author": "n.nethercote@gmail.com", "id": 9899663, "time": "2015-02-09T22:24:59Z"}, {"text": "Created attachment 8562955\npart 1 - Encapsulate recursion level in a class.\n\nThis may be horribly overengineered, but as a preperatory step I encapsulated the recursion level into a class.", "author": "continuation@gmail.com", "id": 9909244, "time": "2015-02-11T19:45:34Z"}, {"text": "Comment on attachment 8562955\npart 1 - Encapsulate recursion level in a class.\n\nReview of attachment 8562955:\n-----------------------------------------------------------------\n\n::: xpcom/glue/pldhash.h\n@@ +159,5 @@\n> +  void Increment();\n> +  void Decrement();\n> +\n> +#ifdef DEBUG\n> +  void MarkImmutable();\n\nI find it strange that some of the methods in this class are DEBUG only, while some are always present but empty when non-DEBUG.\n\nI would make all the methods except the zero-arg constructor DEBUG-ONLY, and use |#ifdef DEBUG| at call sites as necessary, as the current code does. That way you don't have to look at the class's innards to see that calls like mRecursionLevel.increment() are DEBUG-only.", "author": "n.nethercote@gmail.com", "id": 9909408, "time": "2015-02-11T20:19:18Z"}, {"text": "Two other possible nits: \n- Nest RecursionLevel within PLDHashTable?\n- Define RecursionLevel's methods in pldhash.h for conciseness?", "author": "n.nethercote@gmail.com", "id": 9909831, "time": "2015-02-11T21:59:15Z"}, {"text": "(In reply to Nicholas Nethercote [:njn] from comment #3)\n> Two other possible nits: \n> - Nest RecursionLevel within PLDHashTable?\n\nYes.\n\n> - Define RecursionLevel's methods in pldhash.h for conciseness?\n\nNo opinion.", "author": "nfroyd@mozilla.com", "id": 9909839, "time": "2015-02-11T22:01:16Z"}, {"text": "(In reply to Nicholas Nethercote [:njn] from comment #3)\n> Two other possible nits: \n> - Nest RecursionLevel within PLDHashTable?\nYeah, good point.\n\n> - Define RecursionLevel's methods in pldhash.h for conciseness?\nI was doing this to reduce the size of the header file, given how widely it is included. Maybe that isn't a big deal.", "author": "continuation@gmail.com", "id": 9910023, "time": "2015-02-11T22:36:23Z"}, {"text": "I'm probably not going to work on this soon.\n\nThis should let us get rid of a couple of gotos in PLDHashTable::Add().", "author": "continuation@gmail.com", "id": 10041877, "time": "2015-03-17T20:15:40Z"}, {"text": "I'll do it, though I probably won't get to it until May.", "author": "n.nethercote@gmail.com", "id": 10042379, "time": "2015-03-17T21:37:16Z"}, {"text": "I'm looking at this again, and I think the whole mRecursionLevel field is\nflawed, as implemented.\n\nAIUI, it's in one of these three states:\n\n- Mutable(n)\n- Immutable\n\n|Mutable| has a count associated, indicating how many operations are underway.\nIt's safe to have multiple reads going at once, but only one write can be\nhappening at once.\n\n|Search| causes the following transitions (before --> during --> after):\n- Mutable(n) --> Mutable(n+1) --> Mutable(n)\n- Immutable --> Immutable --> Immutable\n\n|Add| and |Remove| cause the following transitions while they're occurring:\n- Mutable(0) --> Mutable(1) --> Mutable(0)\n- Mutable(_) --> ABORT!\n- Immutable --> ABORT!\n\nSo this will catch bad things like if call Search then concurrently call Add.\nBut it will *miss* bad things like if you call Add and then concurrently call\nSearch.\n\nBasically, it's a botched emulation of an rwlock. If we change it to the\nfollowing states, it should work better:\n\n- Read(n)\n- Write\n- Immutable\n\n|Search| would have these transitions:\n- Read(n) --> Read(n+1) --> Read(n)\n- Write --> ABORT!\n- Immutable --> Immutable --> Immutable\n\n|Add| and |Remove| would have these transitions:\n- Read(0) --> Write --> Read(0)\n- Read(n) --> ABORT!\n- Write --> ABORT!\n- Immutable --> ABORT!", "author": "n.nethercote@gmail.com", "id": 10267303, "time": "2015-05-14T04:54:01Z"}, {"text": "Actually, I think the Read(n)/Write status needs to be separate from the Immutable status. Because currently Finish() thinks everything is fine if the table is immutable, even though it's possible that another thread is in the middle of reading it!", "author": "n.nethercote@gmail.com", "id": 10267344, "time": "2015-05-14T05:20:18Z"}, {"text": "Hm, what I tried to do was to make mRecursionLevel a real recursion counter like it was originally trying to be (preventing Add/Remove from being called inside some other operation). I did add a comment saying that this didn't enforce threadafety.\n\nI was thinking we would do the threadsafety checks separately (bug 1164758, which I forgot to file until you reminded me!) since recursion+threadsafety seemed hard to get right with a single counter.\n\nBut I'm happy with anything!", "author": "bent.mozilla@gmail.com", "id": 10267367, "time": "2015-05-14T05:57:05Z"}, {"text": "AFAICT, emulating an rwlock as per comment 8 will provide both recursion and thread-safety checks. Am I missing something?", "author": "n.nethercote@gmail.com", "id": 10267385, "time": "2015-05-14T06:18:49Z"}, {"text": "(In reply to Nicholas Nethercote [:njn] from comment #11)\n> AFAICT, emulating an rwlock as per comment 8 will provide both recursion and\n> thread-safety checks. Am I missing something?\n\nNo, I think it's a great idea, I just meant that I didn't see how it could be done with a single counter like the old code was pretending to do. You just have to have at another variable to track your state, right?", "author": "bent.mozilla@gmail.com", "id": 10267402, "time": "2015-05-14T06:28:29Z"}, {"text": "(Or I guess you could use the high bits)", "author": "bent.mozilla@gmail.com", "id": 10267403, "time": "2015-05-14T06:29:54Z"}, {"text": "My current code has this:\n\n  static const uint32_t kIdle    = 0;\n  static const uint32_t kRead1   = 1;\n  static const uint32_t kReadMax = UINT32_MAX - 1;\n  static const uint32_t kWrite   = UINT32_MAX;\n\nWhich gives a tri-state tagged union covering Idle, Read(n) and Write.\n\nAnd there's also a bool for tracking mutability separately.", "author": "n.nethercote@gmail.com", "id": 10267492, "time": "2015-05-14T07:17:34Z"}, {"text": "Sounds great!", "author": "bent.mozilla@gmail.com", "id": 10269030, "time": "2015-05-14T16:38:36Z"}, {"text": "Created attachment 8615823\n(part 1) - Improve PLDHashTable's internal checking", "author": "n.nethercote@gmail.com", "id": 10349466, "time": "2015-06-05T06:21:36Z"}, {"text": "Created attachment 8615825\n(part 2) - Use RAII for PLDHashTable::mChecker operations", "author": "n.nethercote@gmail.com", "id": 10349469, "time": "2015-06-05T06:21:56Z"}, {"text": "Try looks good: https://treeherder.mozilla.org/#/jobs?repo=try&revision=dd61ddeecfdd", "author": "n.nethercote@gmail.com", "id": 10349602, "time": "2015-06-05T07:13:31Z"}, {"text": "Comment on attachment 8615823\n(part 1) - Improve PLDHashTable's internal checking\n\nReview of attachment 8615823:\n-----------------------------------------------------------------\n\nApologies for letting this review hang around over the weekend.  I am also glad to see that there's a part 2, as part 2 is exactly what my first comment was going to be about. :)\n\nI am not completely sure that some of the small timeslices in the below examples make sense.  I guess the first example is not nearly so problematic (only triggers intermittent oranges, which we already have with the current code?) as the second one; the second one implies that we can actually break the invariants of the class, which seems like bad news.  I didn't exhaustively look for concurrency bugs, and it's entirely possible that my examples below are completely bogus.  Please review.\n\nLooking in my local threading book (_Programming with POSIX Threads_), it looks like what you want is the ability to wait on any pending readers prior to starting a write operation.  But that actually involves locks at the datastructure level, which I don't think is the way we want to go.  So I'm not quite sure where to go with this.\n\n::: xpcom/glue/pldhash.h\n@@ +182,5 @@\n> +    return *this;\n> +  }\n> +\n> +  bool IsIdle()  const { return mState == kIdle; }\n> +  bool IsRead()  const { return kRead1 <= mState && mState <= kReadMax; }\n\nIt seems possible for an assertion using this function to fail, e.g.:\n\nT1: enter StartWriteOp, pass at least the IsIdle assert\n\nNB: at this point, mState == kIdle.\n\nT2: enter StartReadOp\nT2: do whatever read thing we were going to do\nT2: enter EndReadOp, call IsRead()\nT2: test kRead1 <= mState, which is OK\nT1: resume StartWriteOp\nT1: set mState = kWrite\nT1: maybe go and start doing things, maybe yield\nT2: test mState <= kReadMax, which fails and asserts\n\nMaybe that's the point, though?\n\n@@ +208,5 @@\n> +\n> +  void EndReadOp()\n> +  {\n> +    MOZ_ASSERT(IsRead());\n> +    MOZ_ASSERT(mState >= kRead1);\n\nThis assert seems redundant with the IsRead() assert, and seems vulnerable to a similar sequence as described above:\n\nT1: enter StartWriteOp, pass assert\nT2: enter StartReadOp\nT2: do whatever read thing we were going to do\nT2: enter EndReadOp, pass IsRead() assert\nT1: resume StartWriteOp\nT1: set mState = kWrite\nT1: maybe exit StartWriteOp and start writing to the table\nT2: pass mState >= kRead1 assert\nT2: decrement mState\n\nOops, we are now in a position where we think we have a lot of readers, but nobody is writing to the table.", "author": "nfroyd@mozilla.com", "id": 10357555, "time": "2015-06-08T17:32:36Z"}, {"text": "Comment on attachment 8615825\n(part 2) - Use RAII for PLDHashTable::mChecker operations\n\nReview of attachment 8615825:\n-----------------------------------------------------------------\n\nThis part seems fine as far as it goes, but I don't know what changes it might need if part 1 gets modified at all.  So just f+'ing this for now.", "author": "nfroyd@mozilla.com", "id": 10357566, "time": "2015-06-08T17:34:16Z"}, {"text": "Thinking about this a little more, the scenarios described in comment 19 are actually the whole point of the class?  i.e. it's OK if these happen, because they indicate that two threads are using the class incorrectly?\n\nThe second scenario in comment 19 might still be bad, but it's possible I've misunderstood exactly how these checks are intended to function.", "author": "nfroyd@mozilla.com", "id": 10357713, "time": "2015-06-08T18:04:55Z"}, {"text": "Both of your examples start with this:\n\n> T1: enter StartWriteOp, pass assert\n> T2: enter StartReadOp\n\nWe'll assert on the second line because you can't start a new read while you have an in-progress write.\n\n> Thinking about this a little more, the scenarios described in comment 19 are actually the whole point\n> of the class?  i.e. it's OK if these happen, because they indicate that two threads are using the\n> class incorrectly?\n\nThread-safety is intended to come from outside the class. E.g. if a PLDHashTable is accessed from multiple threads, that external code should use locking of some kind. And if it doesn't, this class will hopefully detect that. It will also detect if you have re-entrancy problems within a single thread, e.g. you remove an element which triggers a destructor which somehow triggers another table modification.\n\nMaybe you're concerned that the state checking and modifications done in each of the Start/End functions isn't atomic? For example, it's conceivable that you could have two concurrent writes (which is bad) and if you got really unlucky they could interleave in a way such that Checker would miss it:\n\n> table starts in Idle, Writable state\n> T1: MOZ_ASSERT(IsIdle() && IsWritable());  // passes\n> T2: MOZ_ASSERT(IsIdle() && IsWritable());  // passes\n> T1: mState = kWrite;\n> T2: mState = kWrite;\n\nand then if something similar could happen in EndWriteOp.\n\nI could argue that since this is just checking code, it's not the end of the world if it possibly misses some cases. (E.g. the handling of Enumerate() is already imperfect. I want to eventually change the API to distinguish a read-only Enumerate() from one that removes elements, which would fix that hole, but one thing at a time.)\n\nBut that's not the strongest argument I've ever made. It might be possible to (a) combine mState and mIsWritable into a single value, and (b) use the primitives in mfbt/Atomics.h (e.g. exchange()) to atomically do the check-and-update state operation.\n\nAre we getting clearer? :)", "author": "n.nethercote@gmail.com", "id": 10359236, "time": "2015-06-09T00:42:50Z"}, {"text": "I don't have time to reply to your long, excellent comment, but I wanted to try to clear up this bit:\n\n(In reply to Nicholas Nethercote [:njn] from comment #22)\n> Both of your examples start with this:\n> \n> > T1: enter StartWriteOp, pass assert\n> > T2: enter StartReadOp\n> >\n> > We'll assert on the second line because you can't start a new read while you have an in-progress\n> > write.\n\nThe examples were intended to show that we can pass through the assert in StartWriteOp, i.e. mState == kIdle, but we can get context-switched before we get around to setting mState to kWrite.  And then when we come back to the writing thread, the state is much different than when we passed the assert.", "author": "nfroyd@mozilla.com", "id": 10359543, "time": "2015-06-09T03:35:11Z"}, {"text": "> The examples were intended to show that we can pass through the assert in\n> StartWriteOp, i.e. mState == kIdle, but we can get context-switched before\n> we get around to setting mState to kWrite.\n\nI see, yes, reading comprehension fail on my end.\n\nSo I think we're on the same page now.\n\nFWIW, I think the current code has similar problems with code like this:\n\n  MOZ_ASSERT(mRecursionLevel == 0);\n  INCREMENT_RECURSION_LEVEL(this);\n\nAgain, the state checking and updating are not atomic.", "author": "n.nethercote@gmail.com", "id": 10359565, "time": "2015-06-09T03:51:44Z"}, {"text": "Created attachment 8624396\n(part 0) - PLDHashTable::{,Removing}Iterator subclasses of a new base class, IteratorBase\n\nThis rearrangement is necessary so that we can treat Iterator as a read op and\nRemovingIterator as a write op for checking purposes. (That's not easy to do if\nRemovingIterator is a subclass of Iterator.)\n\nThis also fixes a couple of small problems with RemovingIterator.\n\n- Its move constructor was moving |aOther.mTable| instead of |aOther|. This\n  meant that |aOther| wasn't being zeroed out appropriately. Previously this\n  didn't matter, but with RemovingIterator now being treated as a write op, it\n  was triggering checking failures in ~RemovingIterator because it was as if\n  there were two non-zeroed RemovingIterators running concurrently.\n\n- test_pldhash_RemovingIterator() was testing Iterator's move constructor\n  instead of RemovingIterator's move constructor, due to a copy/paste\n  mistake(!)", "author": "n.nethercote@gmail.com", "id": 10406118, "time": "2015-06-18T18:54:25Z"}, {"text": "Created attachment 8624398\n(part 1) - Improve PLDHashTable's internal checking\n\nThis version has the careful-with-atomicity changes we discussed, which worked\nout pretty nicely.", "author": "n.nethercote@gmail.com", "id": 10406123, "time": "2015-06-18T18:55:16Z"}, {"text": "Created attachment 8624399\n(part 2) - Use RAII for PLDHashTable::mChecker operations\n\nI think this is barely changed from the earlier version that you f+'d.", "author": "n.nethercote@gmail.com", "id": 10406130, "time": "2015-06-18T18:56:17Z"}, {"text": "Comment on attachment 8624398\n(part 1) - Improve PLDHashTable's internal checking\n\nReview of attachment 8624398:\n-----------------------------------------------------------------\n\nApologies for the delay.  This looks great.\n\n::: xpcom/glue/pldhash.h\n@@ +203,5 @@\n> +  // (b) check the old value was reasonable. This ensures we don't have\n> +  // interleaving problems.\n> +  //\n> +  // For |mIsWritable| we don't need to be as careful because it can only in\n> +  // transition in one direction (from writable to non-writable). \n\nNit: trailing whitespace.", "author": "nfroyd@mozilla.com", "id": 10437425, "time": "2015-06-30T20:12:43Z"}, {"text": "> Apologies for the delay.  This looks great.\n\nIt's going to need some more work before landing. I did a try run and got some violations in netwerk/cache2/CacheIndex.cpp where we do an iteration that does both lookups and removes. I think it's valid because its all on one thread and the removes all happen at the end, after the lookups. So I might need to tweak how things work a bit. We weren't getting violations in this code before because these patches strengthen the checking of iteration/enumeration.", "author": "n.nethercote@gmail.com", "id": 10438549, "time": "2015-07-01T00:06:33Z"}, {"text": "Created attachment 8629841\n(part 0) - Fix minor problems with RemovingIterator\n\nThis is a simplified version of the previous part 0 -- it no longer does the\nshared base class, but instead just does the small fixes.", "author": "n.nethercote@gmail.com", "id": 10458100, "time": "2015-07-06T08:48:27Z"}, {"text": "Created attachment 8629842\n(part 1) - Improve PLDHashTable's internal checking\n\nThis is a slightly different version of the previous part 1 and 2 (now merged\nfor my sanity) that treats RemovingIter as a read op except at the end when the\nremoval step occurs when it temporarily is treated like a write operation.", "author": "n.nethercote@gmail.com", "id": 10458105, "time": "2015-07-06T08:49:26Z"}, {"text": "Comment on attachment 8629841\n(part 0) - Fix minor problems with RemovingIterator\n\nReview of attachment 8629841:\n-----------------------------------------------------------------\n\nfroydnj: I'm going to carry over r+ from the previous patches because these versions are only slightly different, but I'll leave them here overnight in case you want to look over them one last time.", "author": "n.nethercote@gmail.com", "id": 10458108, "time": "2015-07-06T08:51:11Z"}, {"text": "Try looks good: https://treeherder.mozilla.org/#/jobs?repo=try&revision=64272c465897", "author": "n.nethercote@gmail.com", "id": 10461959, "time": "2015-07-06T23:50:13Z"}, {"text": "https://hg.mozilla.org/mozilla-central/rev/536de492b391\nhttps://hg.mozilla.org/mozilla-central/rev/02bcd1b7a8aa", "author": "pulsebot@bots.tld", "id": 10465384, "time": "2015-07-07T18:38:46Z"}, {"text": "https://hg.mozilla.org/mozilla-central/rev/536de492b391\nhttps://hg.mozilla.org/mozilla-central/rev/02bcd1b7a8aa", "author": "kwierso@gmail.com", "id": 10465762, "time": "2015-07-07T20:00:11Z"}], "cf_last_resolved": "2015-07-07T20:00:11Z", "priority": "--", "mentors_detail": [], "cf_crash_signature": "", "version": "unspecified", "cf_qa_whiteboard": "", "cf_tracking_firefox_esr52": "---", "cf_tracking_firefox59": "---", "last_change_time": "2015-07-07T20:00:11Z", "cf_platform_rel": "---", "product": "Core", "cf_status_firefox_esr52": "---", "blocks": [1128407], "qa_contact": "", "see_also": [], "cf_fx_iteration": "---", "component": "XPCOM", "votes": 0, "groups": [], "cf_status_firefox60": "---", "cf_status_firefox42": "fixed", "target_milestone": "mozilla42", "is_cc_accessible": true, "cf_status_thunderbird_esr52": "---", "url": "", "creator_detail": {"email": "n.nethercote@gmail.com", "id": 334849, "name": "n.nethercote@gmail.com", "real_name": "Nicholas Nethercote [:njn]"}, "whiteboard": "", "mentors": [], "cc_detail": [{"email": "bent.mozilla@gmail.com", "id": 200444, "name": "bent.mozilla@gmail.com", "real_name": "Ben Turner (not reading bugmail, use the needinfo flag!)"}, {"email": "continuation@gmail.com", "id": 406194, "name": "continuation@gmail.com", "real_name": "Andrew McCreight [:mccr8]"}, {"email": "n.nethercote@gmail.com", "id": 334849, "name": "n.nethercote@gmail.com", "real_name": "Nicholas Nethercote [:njn]"}, {"email": "nfroyd@mozilla.com", "id": 417288, "name": "nfroyd@mozilla.com", "real_name": "Nathan Froyd [:froydnj]"}], "cf_has_str": "---", "alias": null, "dupe_of": null, "flags": [], "cf_tracking_firefox58": "---", "cf_rank": null, "is_open": false, "history": [{"changes": [{"removed": "", "field_name": "blocks", "added": "1128407"}], "who": "n.nethercote@gmail.com", "when": "2015-02-09T22:31:39Z"}, {"changes": [{"removed": "nobody@mozilla.org", "field_name": "assigned_to", "added": "continuation@gmail.com"}], "who": "continuation@gmail.com", "when": "2015-02-11T18:00:27Z"}, {"changes": [{"removed": "continuation@gmail.com", "field_name": "assigned_to", "added": "nobody@mozilla.org"}], "who": "continuation@gmail.com", "when": "2015-03-17T20:15:40Z"}, {"changes": [{"removed": "nobody@mozilla.org", "field_name": "assigned_to", "added": "n.nethercote@gmail.com"}], "who": "n.nethercote@gmail.com", "when": "2015-03-17T21:37:16Z"}, {"changes": [{"removed": "", "field_name": "cc", "added": "bent.mozilla@gmail.com"}], "who": "n.nethercote@gmail.com", "when": "2015-05-14T04:54:01Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "", "attachment_id": 8615823, "added": "review?(nfroyd@mozilla.com)"}], "who": "n.nethercote@gmail.com", "when": "2015-06-05T06:21:36Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "", "attachment_id": 8615825, "added": "review?(nfroyd@mozilla.com)"}], "who": "n.nethercote@gmail.com", "when": "2015-06-05T06:21:56Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(nfroyd@mozilla.com)", "attachment_id": 8615823, "added": ""}], "who": "nfroyd@mozilla.com", "when": "2015-06-08T17:32:36Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(nfroyd@mozilla.com)", "attachment_id": 8615825, "added": "feedback+"}], "who": "nfroyd@mozilla.com", "when": "2015-06-08T17:34:16Z"}, {"changes": [{"removed": "", "field_name": "cc", "added": "n.nethercote@gmail.com"}, {"removed": "", "field_name": "flagtypes.name", "added": "needinfo?(n.nethercote@gmail.com)"}], "who": "nfroyd@mozilla.com", "when": "2015-06-08T18:04:55Z"}, {"changes": [{"removed": "needinfo?(n.nethercote@gmail.com)", "field_name": "flagtypes.name", "added": "needinfo?(nfroyd@mozilla.com)"}], "who": "n.nethercote@gmail.com", "when": "2015-06-09T00:42:50Z"}, {"changes": [{"removed": "needinfo?(nfroyd@mozilla.com)", "field_name": "flagtypes.name", "added": ""}], "who": "nfroyd@mozilla.com", "when": "2015-06-09T03:35:11Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8562955, "added": "1"}], "who": "n.nethercote@gmail.com", "when": "2015-06-18T05:51:13Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "", "attachment_id": 8624396, "added": "review?(nfroyd@mozilla.com)"}], "who": "n.nethercote@gmail.com", "when": "2015-06-18T18:54:25Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "", "attachment_id": 8624398, "added": "review?(nfroyd@mozilla.com)"}], "who": "n.nethercote@gmail.com", "when": "2015-06-18T18:55:16Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8615823, "added": "1"}], "who": "n.nethercote@gmail.com", "when": "2015-06-18T18:55:21Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "", "attachment_id": 8624399, "added": "review?(nfroyd@mozilla.com)"}], "who": "n.nethercote@gmail.com", "when": "2015-06-18T18:56:17Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8615825, "added": "1"}], "who": "n.nethercote@gmail.com", "when": "2015-06-18T18:56:23Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(nfroyd@mozilla.com)", "attachment_id": 8624396, "added": "review+"}], "who": "nfroyd@mozilla.com", "when": "2015-06-26T17:31:20Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(nfroyd@mozilla.com)", "attachment_id": 8624399, "added": "review+"}], "who": "nfroyd@mozilla.com", "when": "2015-06-26T17:44:01Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(nfroyd@mozilla.com)", "attachment_id": 8624398, "added": "review+"}], "who": "nfroyd@mozilla.com", "when": "2015-06-30T20:12:43Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8624398, "added": "1"}], "who": "n.nethercote@gmail.com", "when": "2015-07-06T08:49:29Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8624396, "added": "1"}], "who": "n.nethercote@gmail.com", "when": "2015-07-06T08:50:19Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8624399, "added": "1"}], "who": "n.nethercote@gmail.com", "when": "2015-07-06T08:50:24Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "", "attachment_id": 8629841, "added": "review+"}], "who": "n.nethercote@gmail.com", "when": "2015-07-06T08:51:11Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "", "attachment_id": 8629842, "added": "review+"}], "who": "n.nethercote@gmail.com", "when": "2015-07-06T08:51:19Z"}, {"changes": [{"removed": "NEW", "field_name": "status", "added": "RESOLVED"}, {"removed": "", "field_name": "resolution", "added": "FIXED"}, {"removed": "---", "field_name": "target_milestone", "added": "mozilla42"}, {"removed": "", "field_name": "cf_last_resolved", "added": "2015-07-07 13:00:11"}, {"removed": "---", "field_name": "cf_status_firefox42", "added": "fixed"}], "who": "kwierso@gmail.com", "when": "2015-07-07T20:00:11Z"}], "resolution": "FIXED", "op_sys": "All", "cf_fx_points": "---", "cf_blocking_fennec": "---"}