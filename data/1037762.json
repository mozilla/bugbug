{"cf_tracking_thunderbird_esr52": "---", "status": "RESOLVED", "cf_tracking_firefox60": "---", "cf_tracking_firefox61": "---", "cf_tracking_firefox62": "---", "creator": "duanyao.ustc@gmail.com", "mentors_detail": [], "depends_on": [], "cf_status_firefox_esr60": "---", "cf_user_story": "", "cf_tracking_firefox_relnote": "---", "platform": "x86_64", "keywords": [], "cc_detail": [{"email": "bzbarsky@mit.edu", "id": 20209, "name": "bzbarsky@mit.edu", "real_name": "Boris Zbarsky [:bz] (Vacation Jun 16-24) (no decent commit message means r-)"}, {"email": "danny0838@gmail.com", "id": 420740, "name": "danny0838@gmail.com", "real_name": "Danny Lin"}, {"email": "fb+mozdev@quantumedia.de", "id": 413779, "name": "fb+mozdev@quantumedia.de", "real_name": "Florian Bender"}, {"email": "gphemsley@gphemsley.org", "id": 113791, "name": "gphemsley@gphemsley.org", "real_name": "Gordon P. Hemsley [:GPHemsley]"}], "cf_last_resolved": "2014-07-12T03:14:01Z", "attachments": [{"creator": "duanyao.ustc@gmail.com", "is_obsolete": 0, "is_patch": 0, "flags": [], "content_type": "text/html", "id": 8454847}], "votes": 0, "classification": "Components", "is_confirmed": false, "is_creator_accessible": true, "cf_has_regression_range": "---", "comment_count": 30, "comments": [{"text": "Created attachment 8454847\nxhr-html.htm\n\nUser Agent: Mozilla/5.0 (X11; Linux x86_64; rv:33.0) Gecko/20100101 Firefox/33.0 (Beta/Release)\nBuild ID: 20140703030200\n\nSteps to reproduce:\n\nLoad the attached HTML file (xhr-html.htm) with firefox.\nThe attachment loads itself with XMLHttpRequest, setting responseType = 'document'. The attachment doesn't conform to XHTML syntax.\n\n\n\nActual results:\n\nParse error is shown in console, it seems XMLHttpRequest is parsing it as XHTML:\n\nmismatched tag. Expected: </meta>. xhr-html.htm:17\n\"<parsererror xmlns=\"http://www.mozilla.org/newlayout/xml/parsererror.xml\">XML Parsing Error: mismatched tag. Expected: &lt;/meta&gt;.\nLocation: file:///media/DATA/project/MyHTML/xhr-html.htm\nLine Number 17, Column 3:<sourcetext>&lt;/head&gt;\n--^</sourcetext></parsererror>\"\n\n\nExpected results:\n\nParse the HTML file correctly.\n\nIt seems HTML parsing in XMLHttpRequest was fixed long ago:\nhttps://bugzilla.mozilla.org/show_bug.cgi?id=651072\n\nHowever, firefox 28-33 can't make it right.", "author": "duanyao.ustc@gmail.com", "id": 9046133, "time": "2014-07-12T02:54:56Z"}, {"text": "Note: HTML files served via http: are parsed correctly, but those via file: are not.", "author": "duanyao.ustc@gmail.com", "id": 9046139, "time": "2014-07-12T03:01:29Z"}, {"text": "Note: HTML files are also not parsed correctly via chrome: protocol.", "author": "duanyao.ustc@gmail.com", "id": 9046154, "time": "2014-07-12T03:13:39Z"}, {"text": "From the XMLHttpRequest spec at <https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#response-entity-body-0>:\n\n  The response MIME type is the MIME type the Content-Type header contains excluding any\n  parameters and converted to ASCII lowercase, or null if the response header can not be\n  parsed or was omitted.\n\nWhen loading from file:// this will therefore be null, since there is no Content-Type header.\n\n  Final MIME type is the override MIME type unless that is null in which case it is the\n  response MIME type. \n\nwhich in this case is also null, since the testcase does not call overrideMimeType, and the response MIME type is null.\n\nThen for a response of type \"document\" the relevant spec section is https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#document-response-entity-body which says:\n\n  If final MIME type is text/html, run these substeps: \n\nwhich are not run, since final MIME type is null and then:\n\n  Otherwise, let document be a document that represents the result of parsing the\n  response entity body following the rules set forth in the XML specifications. If that\n  fails (unsupported character encoding, namespace well-formedness error, etc.), return\n  null.\n\nIn other words, when loading from file:// XMLHttpRequest will always parse as XML unless overrideMimeType is called\n\nI don't know why you think this is a regression, exactly; this has always been the behavior.", "author": "bzbarsky@mit.edu", "id": 9046155, "time": "2014-07-12T03:14:01Z"}, {"text": "> Note: HTML files are also not parsed correctly via chrome: protocol.\n\nchrome:// doesn't have a Content-Type header, so yes, you get the same behavior.\n\nReally, XHR is designed to work with XML and HTTP.  The HTML support was shoehorned in, but without breaking backwards compat in the process, which means that it only works reasonably well over HTTP.  Otherwise you have to opt into it with overrideMimeType.", "author": "bzbarsky@mit.edu", "id": 9046156, "time": "2014-07-12T03:15:25Z"}, {"text": "(In reply to Boris Zbarsky [:bz] from comment #3)\n> When loading from file:// this will therefore be null, since there is no\n> Content-Type header.\nI don't think the spec specifies this. In the \"1 Introduction\" section:\n\n  Second, it can be used to make requests over both HTTP and HTTPS (some implementations support \n  protocols in addition to HTTP and HTTPS, but that functionality is not covered by this specification).\n\nSo I think file: and chrome: protocols are just \"not covered\", and the exact behaviors are leaved to the implementors.\n\nIn section \"6 data: URLs and HTTP\", the spec says:\n\n  To ensure data: URLs can function in APIs designed around HTTP, such as XMLHttpRequest, this section \n  details how they work. Specifications defining similar URL schemes ought to take inspiration from this section. \n\n  When a data: URL is fetched using the HTTP method GET, determine the response as follows: \n    ...\n    * Include a single response header whose header field name is \"content-type\" and whose value is the \n    MIME type (including any parameters) given in the data: URL, or the default otherwise. \n\nSo I think the spec allows and encourages XMLHttpRequest implementations to determine the mime type of the response by themselves, if the content-type header is not available in the protocol in question.\n\nFor file: protocol, it is a trivial task to determine mime type by a file's extension name -- <input type=file> element already does that, right? Chrome browser also does exactly this.\n\n> \n> I don't know why you think this is a regression, exactly; this has always\n> been the behavior.\n\nThis is a mistake, I had a illusion that firefox had chrome-like behavior before.", "author": "duanyao.ustc@gmail.com", "id": 9046993, "time": "2014-07-12T21:03:48Z"}, {"text": "(In reply to Boris Zbarsky [:bz] from comment #4)\n> > Note: HTML files are also not parsed correctly via chrome: protocol.\n> \n> chrome:// doesn't have a Content-Type header, so yes, you get the same\n> behavior.\n> \n> Really, XHR is designed to work with XML and HTTP.  The HTML support was\n> shoehorned in, but without breaking backwards compat in the process, which\n> means that it only works reasonably well over HTTP.  Otherwise you have to\n> opt into it with overrideMimeType.\n\nHow can custom codes know what should be passed to overrideMimeType? The most common guess is still according to the file extension. Browsers can also do this, why don't let browser do it, and keep the custom codes simple?\n\nXHR was designed to work with XML and HTTP, but now it is much more versatile. Browser-based applications are not limited to HTTP, not to mention XULRunner.", "author": "duanyao.ustc@gmail.com", "id": 9047009, "time": "2014-07-12T21:27:30Z"}, {"text": "The following code demonstrates that browsers(including firefox) already can determine local file's mime type. So for firefox this functionality should be able to incorporated into XHR.\n\n<input type=\"file\" >Select file</input>\n<script>\ndocument.querySelector('input[type=file]').onchange = function(ev) {\n    var file = ev.target.files[0];\n    console.log(file); //contains the file's mime in 'type' field\n    var url = URL.createObjectURL(file);\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.responseType = 'document';\n    xhr.send(); //works for html\n    xhr.onload = function() {\n        console.log(this.response.documentElement.outerHTML);\n        URL.revokeObjectURL(url);\n    }\n}\n</script>", "author": "duanyao.ustc@gmail.com", "id": 9047020, "time": "2014-07-12T21:52:30Z"}, {"text": "> For file: protocol, it is a trivial task to determine mime type by a file's extension\n\nThat would break backwards compat in a number of cases for XHR, actually, for extensions that end up being neither HTML nor XML.\n\nSeriously, I believe what we implement is correct per the XHR spec.  If you think that spec should change, please raise spec issues as needed.", "author": "bzbarsky@mit.edu", "id": 9047094, "time": "2014-07-13T01:01:00Z"}, {"text": "(In reply to Boris Zbarsky [:bz] from comment #8)\n> > For file: protocol, it is a trivial task to determine mime type by a file's extension\n> \n> That would break backwards compat in a number of cases for XHR, actually,\n> for extensions that end up being neither HTML nor XML.\n\nCan you give some examples? I don't known why users should expect the browser threat a non-popular file extension as XML via file protocol. Even if some of them do, they already break the cross-browser compatibility because chrome etc. don't do that. \n\n> \n> Seriously, I believe what we implement is correct per the XHR spec.  If you\n> think that spec should change, please raise spec issues as needed.\n\nI think the current implementation is \"correct\" just because the current spec doesn't specify the details of file: protocol, it doesn't mean this is the only correct way.\n\nI think the most relevant spec section for this issue should be \"Fetch - 4.1 Basic fetch\" (http://fetch.spec.whatwg.org/#basic-fetch). In this section, for all schemes other than http(s), i.e. about, blob, data, a method to make a fake Content-Type header is specified; however, file and ftp schemes are exception:\n\n    \"file\"\n    \"ftp\"\n\n        For now, unfortunate as it is, file and ftp URLs are left as an exercise for the reader.\n\nSo I believe the methods to make fake Content-Type header for file and ftp schemes are just not covered by this spec for now; it doesn't mean that UAs must or should treat Content-Type as null. I think UAs can and should do a reasonable guess to Content-Type for these schemes, like chrome browser.", "author": "duanyao.ustc@gmail.com", "id": 9047115, "time": "2014-07-13T02:17:46Z"}, {"text": "> I don't known why users should expect the browser threat a non-popular file extension as\n> XML via file protocol.\n\nBecause that's what browsers do.\n\n> Even if some of them do, they already break the cross-browser compatibility because\n> chrome etc. don't do that.\n\nChrome doesn't let you use XHR to file:// URIs at all, unless you're loading the file your web page is in.  So pretty much anything involving local files and XHR is broken in Chrome.\n\nBut other browsers (just tested Safari and Firefox) will let you do XHR to a .txt file and will parse it as XML, for example.\n\nBut more importantly, there is absolutely no way we want to change behavior and then change it _again_ if/when the spec decides to define this.  That's just not an OK thing to do.  So unless the spec defines a behavior here, I don't think we should be changing it from what people are already expecting.", "author": "bzbarsky@mit.edu", "id": 9047127, "time": "2014-07-13T02:44:55Z"}, {"text": "(In reply to Boris Zbarsky [:bz] from comment #10)\n> > I don't known why users should expect the browser threat a non-popular file extension as\n> > XML via file protocol.\n> \n> Because that's what browsers do.\n> \n> > Even if some of them do, they already break the cross-browser compatibility because\n> > chrome etc. don't do that.\n> \n> Chrome doesn't let you use XHR to file:// URIs at all, unless you're loading\n> the file your web page is in.  So pretty much anything involving local files\n> and XHR is broken in Chrome.\n\nNot exactly. \nFirstly chrome has some command line options to relax the constraint to local file XHR, such as --disable-web-security or \u2013allow-file-access-from-files (http://stackoverflow.com/questions/3102819/disable-same-origin-policy-in-chrome), these are convinient for debug web apps locally. \n\nSecondly there are chromium-based embedable runtimes (more or less like xulrunner), such as CEF (http://code.google.com/p/chromiumembedded) and node-webkit (https://github.com/rogerwang/node-webkit), which also allow local XHR.\n\nThirdly, android WebView allow local XHR via file:///android_asset/ pattern or plain file: URLs, and also treat .htm[l] files as text/html type. I note that GeckoView want to simulate file:///android_asset/ pattern (https://bugzilla.mozilla.org/show_bug.cgi?id=948465), so what to do with XHR?\n\nI'll check IE later.\n\n> \n> But other browsers (just tested Safari and Firefox) will let you do XHR to a\n> .txt file and will parse it as XML, for example.\nDon't you think this use pattern is crazy? For me, this indicates a big flaw in a web app. If firefox and safari would shout at me if I misuse a .txt as xml, I would be very appreiciated.\n\n> \n> But more importantly, there is absolutely no way we want to change behavior\n> and then change it _again_ if/when the spec decides to define this.  That's\n> just not an OK thing to do.  So unless the spec defines a behavior here, I\n> don't think we should be changing it from what people are already expecting.\nSure. But you (mozilla) is a big one in w3c and whatwg, and the spec usually take major browsers' implementation into account. So as a web app developer, I'd like to know your position about this incompatibility across browsers. Which behavior do you think should become the spec? \n\nFor me, \"what people are already expecting\" for firefox is actually a flaw. Fixing it will benifit to developers in the long-term.", "author": "duanyao.ustc@gmail.com", "id": 9047237, "time": "2014-07-13T06:01:44Z"}, {"text": "> Which behavior do you think should become the spec? \n\nWhatever behavior we can actually get browsers to agree on.  I'm certainly not wedded to our current behavior; I just don't want to change it willy nilly.", "author": "bzbarsky@mit.edu", "id": 9047282, "time": "2014-07-13T07:45:23Z"}, {"text": "(In reply to Boris Zbarsky [:bz] from comment #12)\n> > Which behavior do you think should become the spec? \n> \n> Whatever behavior we can actually get browsers to agree on.  I'm certainly\n> not wedded to our current behavior; I just don't want to change it willy\n> nilly.\n\nAlright, just hope this to happen soon.", "author": "duanyao.ustc@gmail.com", "id": 9047319, "time": "2014-07-13T08:58:49Z"}, {"text": "It'll happen when it becomes a priority for someone.  If you care about the issue, I strongly suggest you send mail with a spec proposal to the public standards mailing list for XHR.  That's the best way of getting anything to happen here.", "author": "bzbarsky@mit.edu", "id": 9047518, "time": "2014-07-13T14:36:39Z"}, {"text": "(In reply to Boris Zbarsky [:bz] from comment #14)\n> It'll happen when it becomes a priority for someone.  If you care about the\n> issue, I strongly suggest you send mail with a spec proposal to the public\n> standards mailing list for XHR.  That's the best way of getting anything to\n> happen here.\n\nThank you for your suggestion, I'll consider it. But it seems the recent XHR spec doesn't concern about specific protocols (http://xhr.spec.whatwg.org/), maybe this issue is supposed to be addressed by Fetch (http://fetch.spec.whatwg.org) spec?", "author": "duanyao.ustc@gmail.com", "id": 9048654, "time": "2014-07-14T09:16:19Z"}, {"text": "I don't know; I haven't been following the fetch work that closely.", "author": "bzbarsky@mit.edu", "id": 9049061, "time": "2014-07-14T12:00:22Z"}, {"text": "I think I come up with another point that this issue should be fixed, even if the specs haven't been improved -- static resource fetching via file: in firefox already provide reasonable Content-Type header, and thus XHR fetching is inconsistent with it.\n\nFor exmaple, I embed a html(inner.html) into an outer html via <object>, and load them via file: protocol in firefox:\n  \n  <object data=\"inner.html\" type=\"application/xhtml+xml\" typemustmatch=\"\" >fallback!</object>\n\nthen the inner.html is not loaded , \"fallback!\" is shown instead. Obviously, firefox has detected that inner.html is text/html, not application/xhtml+xml indicated by type attr, so refused to load it. If I remove typemustmatch attr, inner.html is loaded, and we can confirm that it is parsed as html by checking its tagName. If I rename inner.html to inner.xhtml, it is also loaded.\n\nAccording to HTML spec (http://www.whatwg.org/specs/web-apps/current-work/multipage/the-iframe-element.html#attr-object-typemustmatch):\n\n   The typemustmatch attribute is a boolean attribute whose presence indicates that the resource\n   specified by the data attribute is only to be used if the value of the type attribute and the\n   Content-Type of the aforementioned resource match.\n\nSo I come to the conclusion that firefox sets reasonable Content-Type header for file: protocol, at least for static resources. \n\nSo the problem is: why not do it for XHR too? I understand this is for legacy codes, but this inconsistency should be fixed sooner or later, right?", "author": "duanyao.ustc@gmail.com", "id": 9054721, "time": "2014-07-15T11:22:12Z"}, {"text": "Firefox can certainly guess a file type for file:// URLs and does so based on a combinarion of extensions and content sniffing.\n\nWhat you're ignoring is that there is a real compat issue here.  You think that .txt files should not be parsed as XML.  But what about .plist files?  Those are XML but get detected as text/plain.  There are lots of other file formats that have all sorts of random MIME types but contain XML.\n\nWhat should happen for those file types?  Do they get treated as XML?  How do we decide?  Do we just treat anything that's not HTML as XML?  Something else?\n\n_That_ is why this needs a spec if we only want to change behavior once.  Because I very much doubt that something we pick here without talking to other UAs would end up being the final specified behavior.", "author": "bzbarsky@mit.edu", "id": 9054750, "time": "2014-07-15T11:38:33Z"}, {"text": "I think your concern is resolvable: XHR fetching just does what static fetching or <input type=file> does.\n\nI have tried\n\n   <object data=\"inner.plist\" type=\"text/xml\" typemustmatch=\"\" >fallback</object>\n\nand it loads, but type=\"text/plain\" not, empty also not (and this is invalid HTML).\n\nI have also tried to show inner.plist's mime by <input> as show in Comment 7, and it is \"\"(empty), and it is parsed by XHR as XML.\n\nSo the answer is clear: .plist is recognized as XML by firefox, not plain text.\n\nFor those extensions that are really \"random\", I have some suggestions:\n\n1. Consult the OS. I suspect some browsers already do this.\n\n2. Treat them as XML. This should keep backward compatibility. However, we should warn developers that this is instable, because new extensions may be registered over time, and they really should set overrideMimeType() if they use home-made extensions.\n\n3. Treat them as application/octet-stream. This my favorite, because browser will warn me if I don't set overrideMimeType() for home-made extensions. However, this may break some legacy code, maybe we can hide this behind a preference.", "author": "duanyao.ustc@gmail.com", "id": 9055214, "time": "2014-07-15T13:29:42Z"}, {"text": "(In reply to Boris Zbarsky [:bz] from comment #18)\n\n> _That_ is why this needs a spec if we only want to change behavior once. \n> Because I very much doubt that something we pick here without talking to\n> other UAs would end up being the final specified behavior.\n\nI think the spec IS there -- MIME. \nWeb developers should use well-known extensions/mime as-is; If not, or they use private extensions, they should call overrideMimeType(), or they are asking for trouble.\n\nLet me make me more clear: I think before all browsers can converge to a same behavior of XHR, firefox can and should converge its static fetching and XHR's behaviors.", "author": "duanyao.ustc@gmail.com", "id": 9055379, "time": "2014-07-15T14:02:43Z"}, {"text": "> So the answer is clear: .plist is recognized as XML by firefox, not plain text.\n\nIt's recognized as text/plain on my (Mac) system.  Welcome to the world of MIME mappings for file://.\n\n> 1. Consult the OS. I suspect some browsers already do this.\n\nWe do this already.\n\n> and they really should set overrideMimeType() if they use home-made extensions.\n\nI don't think .plist is a particularly \"home-made\" extension.  It's a preexisting file format that someone might want to read via XHR.\n\n> I think the spec IS there -- MIME. \n\nThere is no sane spec for getting MIME types out of files, sadly.", "author": "bzbarsky@mit.edu", "id": 9055781, "time": "2014-07-15T15:21:28Z"}, {"text": "(In reply to Boris Zbarsky [:bz] from comment #21)\n> > So the answer is clear: .plist is recognized as XML by firefox, not plain text.\n> \n> It's recognized as text/plain on my (Mac) system.  Welcome to the world of\n> MIME mappings for file://.\n> \n> > 1. Consult the OS. I suspect some browsers already do this.\n> \n> We do this already.\n> \n> > and they really should set overrideMimeType() if they use home-made extensions.\n> \n> I don't think .plist is a particularly \"home-made\" extension.  It's a\n> preexisting file format that someone might want to read via XHR.\nWell, it seems .plist can actually takes one of 3 formats: plain text, XML, and binary, for historical reasons. I think its a poor decision to reuse a extension for completely different formats, and this is where the messes come -- it is very hard or impossible to determine a .plist's actually format, especially on non-apple platforms. \n\nAlso I think .plist IS a home-made extension because it has no standard mime type by IANA, and not used by non-apple platforms. Some one suggests application/x-plist, which is non-standard (http://stackoverflow.com/questions/3603851/what-is-the-http-content-type-for-binary-plist).\n\n> \n> > I think the spec IS there -- MIME. \n> \n> There is no sane spec for getting MIME types out of files, sadly.\nI think there will never be one. But practically, many standard MIME types has recommended extensions, for example PDF: http://www.rfc-editor.org/rfc/rfc3778.txt.\n\nThink about web servers, how do they determine a file's content-type before sending it? The situation is similar. Content-type sent via HTTP by no means more reliable than guessing a local file's mime type.", "author": "duanyao.ustc@gmail.com", "id": 9058805, "time": "2014-07-16T01:03:56Z"}, {"text": "I found another 2 relevant specs:\n\nIn \"HTML - 2.6 Fetching resources - 2.6.4 Determining the type of a resource\" (http://www.whatwg.org/specs/web-apps/current-work/multipage/fetching-resources.html#content-type-sniffing)\uff1a\n\n    The Content-Type metadata of a resource must be obtained and interpreted in a manner consistent \n    with the requirements of the MIME Sniffing specification. \n    The sniffed type of a resource must be found in a manner consistent with the requirements given in\n    the MIME Sniffing specification for finding the sniffed media type of the relevant sequence of\n    octets. [MIMESNIFF]\n\nI interpreted this as: both static fetching and XHR fetching must apply MIME Sniffing algorithm to determine the actually media type.\n\nAnd in MIME Sniffing specification (http://mimesniff.spec.whatwg.org):\n\n   5.1 Interpreting the resource metadata\n   ...\n   If the resource is retrieved directly from the file system, set supplied-type to the MIME type\n   provided by the file system. \n\nI don't known what this really mean: almost no main-stream file systems record MIME type for files. Does it actually want to say \"provided by the operating system\" or \"provided by the file extension\"?\n\nNevertheless, the spec does require UAs to obtain MIME type for local files from somewhere, not just treat MIME type as null.\n\nEven If the supplied-type is undefined, the actually type should be sniffed (7.1 Identifying a resource with an unknown MIME type). Largely searching \"<!DOCTYPE HTML\", \"<HTML\", etc for text/html and \"<?xml\" for text/xml.\n\nSo my conclusion is: XHR to shouldn't mis-intercept local .htm file as XML according the above specs. Even if the OS or filename can't provide useful type info, sniffing should probably gives right content-type. So does .plist files and other.\n\nP.S. Current XHR spec (http://xhr.spec.whatwg.org/) is referencing fetching standard (http://fetch.spec.whatwg.org), which is obviously incomplete, and doesn't mention sniffing. So I think we should consult fetching section in HTML spec (http://www.whatwg.org/specs/web-apps/current-work/multipage/fetching-resources.html) for now.", "author": "duanyao.ustc@gmail.com", "id": 9059791, "time": "2014-07-16T07:54:40Z"}, {"text": "Well, there is still one thing unclear: MIME Sniffing specification defined \"8 Context-specific sniffing\", however no XHR related clause can be found.\n\nIn whatwg wiki (http://wiki.whatwg.org/wiki/Contexts), I can see XHR triggers \"connection\" context, and \"Sniffing Algorithm\" for \"connection\" context is left blank. \n\nWhat do those mean? XHR doesn't sniff at all, and trusts supplied-type?", "author": "duanyao.ustc@gmail.com", "id": 9060187, "time": "2014-07-16T09:51:20Z"}, {"text": "> Nevertheless, the spec does require UAs to obtain MIME type for local files from\n> somewhere, not just treat MIME type as null.\n\nThat's not necessarily backwards compatible in the case of XHR, as I pointed out.\n\n> the actually type should be sniffed \n\nYou missed http://mimesniff.spec.whatwg.org/#determining-the-sniffed-mime-type-of-a-resource step 2.\n\n> XHR doesn't sniff at all, and trusts supplied-type?\n\nYes.", "author": "bzbarsky@mit.edu", "id": 9060854, "time": "2014-07-16T12:13:52Z"}, {"text": "(In reply to Boris Zbarsky [:bz] from comment #25)\n> > Nevertheless, the spec does require UAs to obtain MIME type for local files from\n> > somewhere, not just treat MIME type as null.\n> \n> That's not necessarily backwards compatible in the case of XHR, as I pointed\n> out.\nIf this kind of backward compatibility be kept, consistency between static resource fetching and XHR must be degraded, and cross-browser compatibility is also lost. I think this is a much higher price to pay. Do you think the fetching section of HTML spec should be changed?\n> \n> > the actually type should be sniffed \n> \n> You missed\n> http://mimesniff.spec.whatwg.org/#determining-the-sniffed-mime-type-of-a-\n> resource step 2.\n> \n> > XHR doesn't sniff at all, and trusts supplied-type?\n> \n> Yes.\nstep 2 is about \"no-sniff flag\", but I don't see a sentence states that \"in case of XHR, no-sniff flag should be set\", how are you sure about this?\n\nAlso I don't understand why XHR doesn't sniff? If it does, it may probably handle the .plist formats problem gracefully.", "author": "duanyao.ustc@gmail.com", "id": 9061613, "time": "2014-07-16T14:58:53Z"}, {"text": "> Do you think the fetching section of HTML spec should be changed?\n\nI think this needs to be handled on the spec level one way or another.  I said that already in comment 10.\n\n> but I don't see a sentence states that \"in case of XHR, no-sniff flag should be set\",\n\nFrom http://mimesniff.spec.whatwg.org/#no-sniff-flag :\n\n  A no-sniff flag, which defaults to set if the user agent does not wish to perform\n  sniffing on the resource and unset otherwise. \n\nBasically, UAs can decide whether to sniff or not however they want to, as far as I can tell.\n\nSeriously, if you want to figure out how these various specs interact the right way to do that is the standards mailing lists, where Ian and Anne would see your questions, not this bug.", "author": "bzbarsky@mit.edu", "id": 9061781, "time": "2014-07-16T15:27:29Z"}, {"text": "(In reply to Boris Zbarsky [:bz] from comment #27)\nOK, I'll try the mailing lists. Thanks!", "author": "duanyao.ustc@gmail.com", "id": 9061964, "time": "2014-07-16T15:59:25Z"}, {"text": "*** Bug 1466526 has been marked as a duplicate of this bug. ***", "author": "bzbarsky@mit.edu", "id": 13394938, "time": "2018-06-07T21:21:21Z"}], "id": 1037762, "priority": "--", "cc": ["bzbarsky@mit.edu", "danny0838@gmail.com", "fb+mozdev@quantumedia.de", "gphemsley@gphemsley.org"], "cf_crash_signature": "", "version": "31 Branch", "is_cc_accessible": true, "cf_tracking_firefox_esr52": "---", "see_also": [], "cf_tracking_thunderbird_esr60": "---", "cf_platform_rel": "---", "product": "Core", "cf_fx_iteration": "---", "blocks": [], "qa_contact": "", "creation_time": "2014-07-12T02:54:56Z", "cf_status_firefox_esr52": "---", "component": "DOM", "assigned_to_detail": {"email": "nobody@mozilla.org", "id": 1, "name": "nobody@mozilla.org", "real_name": "Nobody; OK to take it and work on it"}, "cf_tracking_firefox_esr60": "---", "cf_status_firefox62": "---", "cf_status_firefox61": "---", "cf_status_firefox60": "---", "target_milestone": "---", "cf_rank": null, "cf_qa_whiteboard": "", "severity": "normal", "groups": [], "cf_status_thunderbird_esr52": "---", "url": "", "cf_status_thunderbird_esr60": "---", "creator_detail": {"email": "duanyao.ustc@gmail.com", "id": 477135, "name": "duanyao.ustc@gmail.com", "real_name": "Duan Yao"}, "whiteboard": "", "mentors": [], "summary": "XMLHttpRequest can't parse HTML from file: protocol correctly, seems parsing as XHTML", "cf_has_str": "---", "alias": null, "dupe_of": null, "flags": [], "last_change_time": "2018-06-07T21:21:21Z", "assigned_to": "nobody@mozilla.org", "is_open": false, "history": [{"changes": [{"removed": "[regression] XMLHttpRequest can't parse HTML correctly, seems parsing as XHTML", "field_name": "summary", "added": "[regression] XMLHttpRequest can't parse HTML from file: protocol correctly, seems parsing as XHTML"}], "who": "duanyao.ustc@gmail.com", "when": "2014-07-12T03:01:29Z"}, {"changes": [{"removed": "UNCONFIRMED", "field_name": "status", "added": "RESOLVED"}, {"removed": "", "field_name": "cc", "added": "bzbarsky@mit.edu"}, {"removed": "", "field_name": "resolution", "added": "INVALID"}, {"removed": "", "field_name": "cf_last_resolved", "added": "2014-07-11 20:14:01"}], "who": "bzbarsky@mit.edu", "when": "2014-07-12T03:14:01Z"}, {"changes": [{"removed": "[regression] XMLHttpRequest can't parse HTML from file: protocol correctly, seems parsing as XHTML", "field_name": "summary", "added": "XMLHttpRequest can't parse HTML from file: protocol correctly, seems parsing as XHTML"}], "who": "bzbarsky@mit.edu", "when": "2014-07-13T01:27:26Z"}, {"changes": [{"removed": "", "field_name": "cc", "added": "fb+mozdev@quantumedia.de"}], "who": "fb+mozdev@quantumedia.de", "when": "2014-07-20T11:44:26Z"}, {"changes": [{"removed": "", "field_name": "cc", "added": "gphemsley@gphemsley.org"}], "who": "gphemsley@gphemsley.org", "when": "2014-07-27T21:13:28Z"}, {"changes": [{"removed": "", "field_name": "cc", "added": "danny0838@gmail.com"}], "who": "bzbarsky@mit.edu", "when": "2018-06-07T21:21:21Z"}], "resolution": "INVALID", "op_sys": "Linux", "cf_fx_points": "---", "cf_blocking_fennec": "---"}