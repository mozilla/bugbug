{"cf_tracking_thunderbird_esr52": "---", "status": "RESOLVED", "cf_tracking_firefox60": "---", "cf_tracking_firefox61": "---", "cf_tracking_firefox62": "---", "creator": "FranklinWhale@hotmail.com", "mentors_detail": [], "depends_on": [1215295, 1228410], "cf_status_firefox_esr60": "---", "cf_user_story": "", "cf_tracking_firefox_relnote": "47+", "platform": "Unspecified", "keywords": ["dev-doc-needed", "feature"], "cc_detail": [{"email": "bgallia@gmail.com", "id": 541269, "name": "bgallia@gmail.com", "real_name": ""}, {"email": "bugs@pettay.fi", "id": 39966, "name": "bugs@pettay.fi", "real_name": "Olli Pettay [:smaug]"}, {"email": "gijskruitbosch+bugs@gmail.com", "id": 159069, "name": "gijskruitbosch+bugs@gmail.com", "real_name": ":Gijs (he/him)"}, {"email": "jypenator@gmail.com", "id": 248150, "name": "jypenator@gmail.com", "real_name": "Jean-Yves Perrier [:teoli]"}, {"email": "maier1michael@gmail.com", "id": 518305, "name": "maier1michael@gmail.com", "real_name": ""}, {"email": "mcastelluccio@mozilla.com", "id": 420453, "name": "mcastelluccio@mozilla.com", "real_name": "Marco Castelluccio [:marco]"}, {"email": "rkothari@mozilla.com", "id": 538805, "name": "rkothari@mozilla.com", "real_name": "Ritu Kothari (:ritu)"}, {"email": "rlb@ipv.sx", "id": 373085, "name": "rlb@ipv.sx", "real_name": "Richard Barnes [:rbarnes]"}, {"email": "ttaubert@mozilla.com", "id": 402526, "name": "ttaubert@mozilla.com", "real_name": "Tim Taubert [:ttaubert] (inactive)"}], "cf_last_resolved": "2016-01-27T11:10:05Z", "attachments": [{"creator": "ttaubert@mozilla.com", "is_obsolete": 1, "is_patch": 1, "flags": [], "content_type": "text/plain", "id": 8673557}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 1, "is_patch": 1, "flags": [], "content_type": "text/plain", "id": 8673558}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 1, "is_patch": 1, "flags": [], "content_type": "text/plain", "id": 8673808}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 1, "is_patch": 1, "flags": [], "content_type": "text/plain", "id": 8673810}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 1, "is_patch": 1, "flags": [], "content_type": "text/plain", "id": 8673811}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 1, "is_patch": 1, "flags": [], "content_type": "text/plain", "id": 8673845}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 1, "is_patch": 1, "flags": [], "content_type": "text/plain", "id": 8673864}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 0, "is_patch": 1, "flags": [{"status": "+", "name": "review", "modification_date": "2015-12-15T17:44:01Z", "type_id": 4, "creation_date": "2015-11-17T11:40:47Z", "id": 1293849, "setter": "rlb@ipv.sx"}], "content_type": "text/plain", "id": 8688415}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 1, "is_patch": 1, "flags": [{"status": "-", "name": "review", "modification_date": "2015-12-15T20:14:06Z", "type_id": 4, "creation_date": "2015-11-17T11:41:09Z", "id": 1293850, "setter": "rlb@ipv.sx"}, {"status": "+", "name": "review", "modification_date": "2015-11-17T13:18:13Z", "type_id": 4, "creation_date": "2015-11-17T11:42:32Z", "id": 1293852, "setter": "bugs@pettay.fi"}], "content_type": "text/plain", "id": 8688416}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 0, "is_patch": 1, "flags": [{"status": "+", "name": "review", "modification_date": "2015-12-15T20:20:17Z", "type_id": 4, "creation_date": "2015-11-17T11:41:36Z", "id": 1293851, "setter": "rlb@ipv.sx"}], "content_type": "text/plain", "id": 8688417}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 1, "is_patch": 1, "flags": [{"status": "-", "name": "review", "modification_date": "2016-01-20T20:53:39Z", "type_id": 4, "creation_date": "2016-01-19T20:48:16Z", "id": 1326292, "setter": "rlb@ipv.sx"}], "content_type": "text/plain", "id": 8709607}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 0, "is_patch": 1, "flags": [{"status": "+", "name": "review", "modification_date": "2016-01-22T21:27:16Z", "type_id": 4, "creation_date": "2016-01-22T14:39:46Z", "id": 1328572, "setter": "rlb@ipv.sx"}], "content_type": "text/plain", "id": 8711000}, {"creator": "ttaubert@mozilla.com", "is_obsolete": 0, "is_patch": 1, "flags": [{"status": "+", "name": "review", "modification_date": "2016-01-23T15:59:03Z", "type_id": 4, "creation_date": "2016-01-22T15:18:12Z", "id": 1328601, "setter": "rlb@ipv.sx"}], "content_type": "text/plain", "id": 8711021}], "votes": 2, "classification": "Components", "is_confirmed": true, "is_creator_accessible": true, "cf_has_regression_range": "---", "is_cc_accessible": true, "comment_count": 31, "comments": [{"text": "User Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64; Trident/7.0; .NET4.0E; .NET4.0C; .NET CLR 3.5.30729; .NET CLR 2.0.50727; .NET CLR 3.0.30729; GWX:RESERVED; rv:11.0) like Gecko\n\nSteps to reproduce:\n\nRSA-PSS is currently not supported in the WebCrypto API of Firefox. I think it should be supported for interoperability, as both Microsoft Edge and Google Chrome support that.\n\nA test page written by Daniel Roesler is available at https://diafygi.github.io/webcrypto-examples/\n\n\nActual results:\n\nAll RSA-PSS operations fail\n\n\nExpected results:\n\nAll RSA-PSS operations should work", "author": "FranklinWhale@hotmail.com", "id": 10587263, "time": "2015-08-06T18:23:03Z"}, {"text": "Created attachment 8673557\n0001-Bug-1191936-Implement-RSA-PSS-key-generation.patch", "author": "ttaubert@mozilla.com", "id": 10836734, "time": "2015-10-14T09:39:54Z"}, {"text": "Created attachment 8673558\n0002-Bug-1191936-Implement-RSA-PSS-signing-and-verificati.patch", "author": "ttaubert@mozilla.com", "id": 10836735, "time": "2015-10-14T09:40:06Z"}, {"text": "Created attachment 8673808\n0001-Bug-1191936-Implement-RSA-PSS-key-generation.patch", "author": "ttaubert@mozilla.com", "id": 10838613, "time": "2015-10-14T18:04:59Z"}, {"text": "Created attachment 8673810\n0002-Bug-1191936-Implement-RSA-PSS-signing-and-verificati.patch", "author": "ttaubert@mozilla.com", "id": 10838617, "time": "2015-10-14T18:05:30Z"}, {"text": "Created attachment 8673811\n0003-Bug-1191936-Implement-SPKI-import-export-for-RSA-PSS.patch", "author": "ttaubert@mozilla.com", "id": 10838619, "time": "2015-10-14T18:05:44Z"}, {"text": "Created attachment 8673845\n0004-Bug-1191936-Implement-PKCS-8-import-export-for-RSA-P.patch", "author": "ttaubert@mozilla.com", "id": 10838950, "time": "2015-10-14T19:39:25Z"}, {"text": "Created attachment 8673864\n0003-Bug-1191936-Implement-SPKI-PKCS-8-JWK-import-export-.patch", "author": "ttaubert@mozilla.com", "id": 10839074, "time": "2015-10-14T20:10:33Z"}, {"text": "Ok, that's pretty much good to go. Now we just need to get these APIs into NSS.", "author": "ttaubert@mozilla.com", "id": 10839550, "time": "2015-10-14T21:53:34Z"}, {"text": "Created attachment 8688415\n0001-Bug-1191936-Implement-RSA-PSS-key-generation.patch\n\nWe need to wait until bug 1215295 hits m-c but I figured we could get the patches reviewed before. If you want to build just check out latest NSS to security/nss/ in your working copy.", "author": "ttaubert@mozilla.com", "id": 10939161, "time": "2015-11-17T11:40:47Z"}, {"text": "Created attachment 8688416\n0002-Bug-1191936-Implement-RSA-PSS-signing-and-verificati.patch", "author": "ttaubert@mozilla.com", "id": 10939163, "time": "2015-11-17T11:41:09Z"}, {"text": "Created attachment 8688417\n0003-Bug-1191936-Implement-SPKI-PKCS-8-JWK-import-export-.patch", "author": "ttaubert@mozilla.com", "id": 10939166, "time": "2015-11-17T11:41:36Z"}, {"text": "Comment on attachment 8688416\n0002-Bug-1191936-Implement-RSA-PSS-signing-and-verificati.patch\n\nOlli, can you please sign off the SubtleCrypto.webidl changes?\n\nhttps://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#RsaPssParams-dictionary", "author": "ttaubert@mozilla.com", "id": 10939168, "time": "2015-11-17T11:42:32Z"}, {"text": "Comment on attachment 8688416\n0002-Bug-1191936-Implement-RSA-PSS-signing-and-verificati.patch\n\n>From 608ed7485bbf31c9185cd7134371a775ce08233b Mon Sep 17 00:00:00 2001\n>From: Tim Taubert <ttaubert@mozilla.com>\n>Date: Tue, 13 Oct 2015 20:22:43 +0200\n>Subject: Bug 1191936 - Implement RSA-PSS signing and verification\n>\n>\n>diff --git a/dom/crypto/WebCryptoTask.cpp b/dom/crypto/WebCryptoTask.cpp\n>index 6ac769a..5573610 100644\n>--- a/dom/crypto/WebCryptoTask.cpp\n>+++ b/dom/crypto/WebCryptoTask.cpp\n>@@ -259,16 +259,51 @@ MapOIDTagToNamedCurve(SECOidTag aOIDTag, nsString& aResult)\n>       break;\n>     default:\n>       return false;\n>   }\n> \n>   return true;\n> }\n> \n>+inline SECOidTag\n>+MapHashAlgorithmNameToOID(const nsString& aName)\n>+{\n>+  SECOidTag hashOID(SEC_OID_UNKNOWN);\n>+\n>+  if (aName.EqualsLiteral(WEBCRYPTO_ALG_SHA1)) {\n>+    hashOID = SEC_OID_SHA1;\n>+  } else if (aName.EqualsLiteral(WEBCRYPTO_ALG_SHA256)) {\n>+    hashOID = SEC_OID_SHA256;\n>+  } else if (aName.EqualsLiteral(WEBCRYPTO_ALG_SHA384)) {\n>+    hashOID = SEC_OID_SHA384;\n>+  } else if (aName.EqualsLiteral(WEBCRYPTO_ALG_SHA512)) {\n>+    hashOID = SEC_OID_SHA512;\n>+  }\n>+\n>+  return hashOID;\n>+}\n>+\n>+inline CK_MECHANISM_TYPE\n>+MapHashAlgorithmNameToMgfMechanism(const nsString& aName) {\n>+  CK_MECHANISM_TYPE mech(UNKNOWN_CK_MECHANISM);\n>+\n>+  if (aName.EqualsLiteral(WEBCRYPTO_ALG_SHA1)) {\n>+    mech = CKG_MGF1_SHA1;\n>+  } else if (aName.EqualsLiteral(WEBCRYPTO_ALG_SHA256)) {\n>+    mech = CKG_MGF1_SHA256;\n>+  } else if (aName.EqualsLiteral(WEBCRYPTO_ALG_SHA384)) {\n>+    mech = CKG_MGF1_SHA384;\n>+  } else if (aName.EqualsLiteral(WEBCRYPTO_ALG_SHA512)) {\n>+    mech = CKG_MGF1_SHA512;\n>+  }\n>+\n>+  return mech;\n>+}\n>+\n> // Helper function to clone data from an ArrayBuffer or ArrayBufferView object\n> inline bool\n> CloneData(JSContext* aCx, CryptoBuffer& aDst, JS::Handle<JSObject*> aSrc)\n> {\n>   MOZ_ASSERT(NS_IsMainThread());\n> \n>   // Try ArrayBuffer\n>   RootedTypedArray<ArrayBuffer> ab(aCx);\n>@@ -833,34 +868,25 @@ public:\n>       }\n> \n>       if (params.mLabel.WasPassed()) {\n>         ATTEMPT_BUFFER_INIT(mLabel, params.mLabel.Value());\n>       }\n>     }\n>     // Otherwise mLabel remains the empty octet string, as intended\n> \n>-    // Look up the MGF based on the KeyAlgorithm.\n>-    // static_cast is safe because we only get here if the algorithm name\n>-    // is RSA-OAEP, and that only happens if we've constructed\n>-    // an RsaHashedKeyAlgorithm.\n>-    mHashMechanism = KeyAlgorithmProxy::GetMechanism(aKey.Algorithm().mRsa.mHash);\n>-\n>-    switch (mHashMechanism) {\n>-      case CKM_SHA_1:\n>-        mMgfMechanism = CKG_MGF1_SHA1; break;\n>-      case CKM_SHA256:\n>-        mMgfMechanism = CKG_MGF1_SHA256; break;\n>-      case CKM_SHA384:\n>-        mMgfMechanism = CKG_MGF1_SHA384; break;\n>-      case CKM_SHA512:\n>-        mMgfMechanism = CKG_MGF1_SHA512; break;\n>-      default:\n>-        mEarlyRv = NS_ERROR_DOM_NOT_SUPPORTED_ERR;\n>-        return;\n>+    KeyAlgorithm& hashAlg = aKey.Algorithm().mRsa.mHash;\n>+    mHashMechanism = KeyAlgorithmProxy::GetMechanism(hashAlg);\n>+    mMgfMechanism = MapHashAlgorithmNameToMgfMechanism(hashAlg.mName);\n>+\n>+    // Check we found appropriate mechanisms.\n>+    if (mHashMechanism == UNKNOWN_CK_MECHANISM ||\n>+        mMgfMechanism == UNKNOWN_CK_MECHANISM) {\n>+      mEarlyRv = NS_ERROR_DOM_NOT_SUPPORTED_ERR;\n>+      return;\n>     }\n>   }\n> \n> private:\n>   CK_MECHANISM_TYPE mHashMechanism;\n>   CK_MECHANISM_TYPE mMgfMechanism;\n>   ScopedSECKEYPrivateKey mPrivKey;\n>   ScopedSECKEYPublicKey mPubKey;\n>@@ -1035,165 +1061,187 @@ class AsymmetricSignVerifyTask : public WebCryptoTask\n> public:\n>   AsymmetricSignVerifyTask(JSContext* aCx,\n>                            const ObjectOrString& aAlgorithm,\n>                            CryptoKey& aKey,\n>                            const CryptoOperationData& aSignature,\n>                            const CryptoOperationData& aData,\n>                            bool aSign)\n>     : mOidTag(SEC_OID_UNKNOWN)\n>+    , mHashMechanism(UNKNOWN_CK_MECHANISM)\n>+    , mMgfMechanism(UNKNOWN_CK_MECHANISM)\n>     , mPrivKey(aKey.GetPrivateKey())\n>     , mPubKey(aKey.GetPublicKey())\n>+    , mSaltLength(0)\n>     , mSign(aSign)\n>     , mVerified(false)\n>-    , mEcdsa(false)\n>+    , mIsRsaPkcs1(false)\n>+    , mIsRsaPss(false)\n>   {\n>     ATTEMPT_BUFFER_INIT(mData, aData);\n>     if (!aSign) {\n>       ATTEMPT_BUFFER_INIT(mSignature, aSignature);\n>     }\n> \n>     nsString algName;\n>+    nsString hashAlgName;\n>     mEarlyRv = GetAlgorithmName(aCx, aAlgorithm, algName);\n>     if (NS_FAILED(mEarlyRv)) {\n>       return;\n>     }\n> \n>-    // Look up the SECOidTag\n>     if (algName.EqualsLiteral(WEBCRYPTO_ALG_RSASSA_PKCS1)) {\n>-      mEcdsa = false;\n>+      mIsRsaPkcs1 = true;\n>       Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, TA_RSASSA_PKCS1);\n>       CHECK_KEY_ALGORITHM(aKey.Algorithm(), WEBCRYPTO_ALG_RSASSA_PKCS1);\n>+      hashAlgName = aKey.Algorithm().mRsa.mHash.mName;\n>+    } else if (algName.EqualsLiteral(WEBCRYPTO_ALG_RSA_PSS)) {\n>+      mIsRsaPss = true;\n>+      Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, TA_RSA_PSS);\n>+      CHECK_KEY_ALGORITHM(aKey.Algorithm(), WEBCRYPTO_ALG_RSA_PSS);\n>+\n>+      KeyAlgorithm& hashAlg = aKey.Algorithm().mRsa.mHash;\n>+      hashAlgName = hashAlg.mName;\n>+      mHashMechanism = KeyAlgorithmProxy::GetMechanism(hashAlg);\n>+      mMgfMechanism = MapHashAlgorithmNameToMgfMechanism(hashAlgName);\n>+\n>+      // Check we found appropriate mechanisms.\n>+      if (mHashMechanism == UNKNOWN_CK_MECHANISM ||\n>+          mMgfMechanism == UNKNOWN_CK_MECHANISM) {\n>+        mEarlyRv = NS_ERROR_DOM_NOT_SUPPORTED_ERR;\n>+        return;\n>+      }\n> \n>-      // For RSA, the hash name comes from the key algorithm\n>-      nsString hashName = aKey.Algorithm().mRsa.mHash.mName;\n>-      switch (MapAlgorithmNameToMechanism(hashName)) {\n>-        case CKM_SHA_1:\n>-          mOidTag = SEC_OID_PKCS1_SHA1_WITH_RSA_ENCRYPTION; break;\n>-        case CKM_SHA256:\n>-          mOidTag = SEC_OID_PKCS1_SHA256_WITH_RSA_ENCRYPTION; break;\n>-        case CKM_SHA384:\n>-          mOidTag = SEC_OID_PKCS1_SHA384_WITH_RSA_ENCRYPTION; break;\n>-        case CKM_SHA512:\n>-          mOidTag = SEC_OID_PKCS1_SHA512_WITH_RSA_ENCRYPTION; break;\n>-        default:\n>-          mEarlyRv = NS_ERROR_DOM_NOT_SUPPORTED_ERR;\n>-          return;\n>+      RootedDictionary<RsaPssParams> params(aCx);\n>+      mEarlyRv = Coerce(aCx, params, aAlgorithm);\n>+      if (NS_FAILED(mEarlyRv)) {\n>+        mEarlyRv = NS_ERROR_DOM_SYNTAX_ERR;\n>+        return;\n>       }\n>+\n>+      mSaltLength = params.mSaltLength;\n>     } else if (algName.EqualsLiteral(WEBCRYPTO_ALG_ECDSA)) {\n>-      mEcdsa = true;\n>       Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, TA_ECDSA);\n>       CHECK_KEY_ALGORITHM(aKey.Algorithm(), WEBCRYPTO_ALG_ECDSA);\n> \n>       // For ECDSA, the hash name comes from the algorithm parameter\n>       RootedDictionary<EcdsaParams> params(aCx);\n>       mEarlyRv = Coerce(aCx, params, aAlgorithm);\n>       if (NS_FAILED(mEarlyRv)) {\n>         mEarlyRv = NS_ERROR_DOM_SYNTAX_ERR;\n>         return;\n>       }\n> \n>-      nsString hashName;\n>-      mEarlyRv = GetAlgorithmName(aCx, params.mHash, hashName);\n>+      mEarlyRv = GetAlgorithmName(aCx, params.mHash, hashAlgName);\n>       if (NS_FAILED(mEarlyRv)) {\n>         mEarlyRv = NS_ERROR_DOM_SYNTAX_ERR;\n>         return;\n>       }\n>-\n>-      CK_MECHANISM_TYPE hashMechanism = MapAlgorithmNameToMechanism(hashName);\n>-      if (hashMechanism == UNKNOWN_CK_MECHANISM) {\n>-        mEarlyRv = NS_ERROR_DOM_SYNTAX_ERR;\n>-        return;\n>-      }\n>-\n>-      switch (hashMechanism) {\n>-        case CKM_SHA_1:\n>-          mOidTag = SEC_OID_ANSIX962_ECDSA_SHA1_SIGNATURE; break;\n>-        case CKM_SHA256:\n>-          mOidTag = SEC_OID_ANSIX962_ECDSA_SHA256_SIGNATURE; break;\n>-        case CKM_SHA384:\n>-          mOidTag = SEC_OID_ANSIX962_ECDSA_SHA384_SIGNATURE; break;\n>-        case CKM_SHA512:\n>-          mOidTag = SEC_OID_ANSIX962_ECDSA_SHA512_SIGNATURE; break;\n>-        default:\n>-          mEarlyRv = NS_ERROR_DOM_NOT_SUPPORTED_ERR;\n>-          return;\n>-      }\n>     } else {\n>       // This shouldn't happen; CreateSignVerifyTask shouldn't create\n>       // one of these unless it's for the above algorithms.\n>       MOZ_ASSERT(false);\n>     }\n> \n>+    // Determine hash algorithm to use.\n>+    mOidTag = MapHashAlgorithmNameToOID(hashAlgName);\n>+    if (mOidTag == SEC_OID_UNKNOWN) {\n>+      mEarlyRv = NS_ERROR_DOM_NOT_SUPPORTED_ERR;\n>+      return;\n>+    }\n>+\n>     // Check that we have the appropriate key\n>     if ((mSign && !mPrivKey) || (!mSign && !mPubKey)) {\n>       mEarlyRv = NS_ERROR_DOM_INVALID_ACCESS_ERR;\n>       return;\n>     }\n>   }\n> \n> private:\n>   SECOidTag mOidTag;\n>+  CK_MECHANISM_TYPE mHashMechanism;\n>+  CK_MECHANISM_TYPE mMgfMechanism;\n>   ScopedSECKEYPrivateKey mPrivKey;\n>   ScopedSECKEYPublicKey mPubKey;\n>   CryptoBuffer mSignature;\n>   CryptoBuffer mData;\n>+  uint32_t mSaltLength;\n>   bool mSign;\n>   bool mVerified;\n>-  bool mEcdsa;\n>+  bool mIsRsaPkcs1;\n>+  bool mIsRsaPss;\n> \n>   virtual nsresult DoCrypto() override\n>   {\n>-    nsresult rv;\n>-    if (mSign) {\n>-      ScopedSECItem signature(::SECITEM_AllocItem(nullptr, nullptr, 0));\n>-      if (!signature.get()) {\n>+    SECStatus rv;\n>+    ScopedSECItem hash(::SECITEM_AllocItem(nullptr, nullptr,\n>+                                           HASH_ResultLenByOidTag(mOidTag)));\n>+    if (!hash) {\n>+      return NS_ERROR_DOM_OPERATION_ERR;\n>+    }\n>+\n>+    // Compute digest over given data.\n>+    rv = PK11_HashBuf(mOidTag, hash->data, mData.Elements(), mData.Length());\n>+    NS_ENSURE_SUCCESS(MapSECStatus(rv), NS_ERROR_DOM_OPERATION_ERR);\n>+\n>+    // Wrap hash in a digest info template (RSA-PKCS1 only).\n>+    if (mIsRsaPkcs1) {\n>+      ScopedSGNDigestInfo di(SGN_CreateDigestInfo(mOidTag, hash->data, hash->len));\n>+      if (!di) {\n>         return NS_ERROR_DOM_OPERATION_ERR;\n>       }\n> \n>-      rv = MapSECStatus(SEC_SignData(signature, mData.Elements(),\n>-                                     mData.Length(), mPrivKey, mOidTag));\n>+      // Reuse |hash|.\n>+      SECITEM_FreeItem(hash, false);\n>+      if (!SGN_EncodeDigestInfo(nullptr, hash, di)) {\n>+        return NS_ERROR_DOM_OPERATION_ERR;\n>+      }\n>+    }\n> \n>-      if (mEcdsa) {\n>-        // DER-decode the signature\n>-        int signatureLength = PK11_SignatureLen(mPrivKey);\n>-        ScopedSECItem rawSignature(DSAU_DecodeDerSigToLen(signature.get(),\n>-                                                          signatureLength));\n>-        if (!rawSignature.get()) {\n>-          return NS_ERROR_DOM_OPERATION_ERR;\n>-        }\n>+    SECItem* params = nullptr;\n>+    CK_MECHANISM_TYPE mech = PK11_MapSignKeyType((mSign ? mPrivKey->keyType :\n>+                                                          mPubKey->keyType));\n> \n>-        ATTEMPT_BUFFER_ASSIGN(mSignature, rawSignature);\n>-      } else {\n>-        ATTEMPT_BUFFER_ASSIGN(mSignature, signature);\n>-      }\n>+    CK_RSA_PKCS_PSS_PARAMS rsaPssParams;\n>+    SECItem rsaPssParamsItem = { siBuffer, };\n> \n>-    } else {\n>-      ScopedSECItem signature(::SECITEM_AllocItem(nullptr, nullptr, 0));\n>-      if (!signature.get()) {\n>-        return NS_ERROR_DOM_UNKNOWN_ERR;\n>-      }\n>+    // Set up parameters for RSA-PSS.\n>+    if (mIsRsaPss) {\n>+      rsaPssParams.hashAlg = mHashMechanism;\n>+      rsaPssParams.mgf = mMgfMechanism;\n>+      rsaPssParams.sLen = mSaltLength;\n> \n>-      if (mEcdsa) {\n>-        // DER-encode the signature\n>-        ScopedSECItem rawSignature(::SECITEM_AllocItem(nullptr, nullptr, 0));\n>-        if (!rawSignature || !mSignature.ToSECItem(nullptr, rawSignature)) {\n>-          return NS_ERROR_DOM_UNKNOWN_ERR;\n>-        }\n>+      rsaPssParamsItem.data = (unsigned char*)&rsaPssParams;\n>+      rsaPssParamsItem.len = sizeof(rsaPssParams);\n>+      params = &rsaPssParamsItem;\n> \n>-        rv = MapSECStatus(DSAU_EncodeDerSigWithLen(signature, rawSignature,\n>-                                                   rawSignature->len));\n>-        NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_OPERATION_ERR);\n>-      } else if (!mSignature.ToSECItem(nullptr, signature)) {\n>-        return NS_ERROR_DOM_UNKNOWN_ERR;\n>+      mech = CKM_RSA_PKCS_PSS;\n>+    }\n>+\n>+    // Allocate SECItem to hold the signature.\n>+    uint32_t len = mSign ? PK11_SignatureLen(mPrivKey) : 0;\n>+    ScopedSECItem sig(::SECITEM_AllocItem(nullptr, nullptr, len));\n>+    if (!sig) {\n>+      return NS_ERROR_DOM_OPERATION_ERR;\n>+    }\n>+\n>+    if (mSign) {\n>+      // Sign the hash.\n>+      rv = PK11_SignWithMechanism(mPrivKey, mech, params, sig, hash);\n>+      NS_ENSURE_SUCCESS(MapSECStatus(rv), NS_ERROR_DOM_OPERATION_ERR);\n>+      ATTEMPT_BUFFER_ASSIGN(mSignature, sig);\n>+    } else {\n>+      // Copy the given signature to the SECItem.\n>+      if (!mSignature.ToSECItem(nullptr, sig)) {\n>+        return NS_ERROR_DOM_OPERATION_ERR;\n>       }\n> \n>-      rv = MapSECStatus(VFY_VerifyData(mData.Elements(), mData.Length(),\n>-                                       mPubKey, signature, mOidTag, nullptr));\n>-      mVerified = NS_SUCCEEDED(rv);\n>+      // Verify the signature.\n>+      rv = PK11_VerifyWithMechanism(mPubKey, mech, params, sig, hash, nullptr);\n>+      mVerified = NS_SUCCEEDED(MapSECStatus(rv));\n>     }\n> \n>     return NS_OK;\n>   }\n> \n>   virtual void Resolve() override\n>   {\n>     if (mSign) {\n>@@ -1218,32 +1266,29 @@ public:\n>     mEarlyRv = GetAlgorithmName(aCx, aAlgorithm, algName);\n>     if (NS_FAILED(mEarlyRv)) {\n>       mEarlyRv = NS_ERROR_DOM_SYNTAX_ERR;\n>       return;\n>     }\n> \n>     TelemetryAlgorithm telemetryAlg;\n>     if (algName.EqualsLiteral(WEBCRYPTO_ALG_SHA1))   {\n>-      mOidTag = SEC_OID_SHA1;\n>       telemetryAlg = TA_SHA_1;\n>     } else if (algName.EqualsLiteral(WEBCRYPTO_ALG_SHA256)) {\n>-      mOidTag = SEC_OID_SHA256;\n>       telemetryAlg = TA_SHA_224;\n>     } else if (algName.EqualsLiteral(WEBCRYPTO_ALG_SHA384)) {\n>-      mOidTag = SEC_OID_SHA384;\n>       telemetryAlg = TA_SHA_256;\n>     } else if (algName.EqualsLiteral(WEBCRYPTO_ALG_SHA512)) {\n>-      mOidTag = SEC_OID_SHA512;\n>       telemetryAlg = TA_SHA_384;\n>     } else {\n>       mEarlyRv = NS_ERROR_DOM_SYNTAX_ERR;\n>       return;\n>     }\n>     Telemetry::Accumulate(Telemetry::WEBCRYPTO_ALG, telemetryAlg);\n>+    mOidTag = MapHashAlgorithmNameToOID(algName);\n>   }\n> \n> private:\n>   SECOidTag mOidTag;\n>   CryptoBuffer mData;\n> \n>   virtual nsresult DoCrypto() override\n>   {\n>@@ -3034,16 +3079,17 @@ WebCryptoTask::CreateSignVerifyTask(JSContext* aCx,\n>   nsresult rv = GetAlgorithmName(aCx, aAlgorithm, algName);\n>   if (NS_FAILED(rv)) {\n>     return new FailureTask(rv);\n>   }\n> \n>   if (algName.EqualsLiteral(WEBCRYPTO_ALG_HMAC)) {\n>     return new HmacTask(aCx, aAlgorithm, aKey, aSignature, aData, aSign);\n>   } else if (algName.EqualsLiteral(WEBCRYPTO_ALG_RSASSA_PKCS1) ||\n>+             algName.EqualsLiteral(WEBCRYPTO_ALG_RSA_PSS) ||\n>              algName.EqualsLiteral(WEBCRYPTO_ALG_ECDSA)) {\n>     return new AsymmetricSignVerifyTask(aCx, aAlgorithm, aKey, aSignature,\n>                                         aData, aSign);\n>   }\n> \n>   return new FailureTask(NS_ERROR_DOM_NOT_SUPPORTED_ERR);\n> }\n> \n>diff --git a/dom/crypto/test/test_WebCrypto_RSA_PSS.html b/dom/crypto/test/test_WebCrypto_RSA_PSS.html\n>index d4835cd..9fa7d1c 100644\n>--- a/dom/crypto/test/test_WebCrypto_RSA_PSS.html\n>+++ b/dom/crypto/test/test_WebCrypto_RSA_PSS.html\n>@@ -36,16 +36,47 @@ TestArray.addTest(\n>       modulusLength: 1024,\n>       publicExponent: new Uint8Array([0x01, 0x00, 0x01])\n>     };\n> \n>     crypto.subtle.generateKey(alg, false, [\"sign\", \"verify\"])\n>       .then(complete(that), error(that));\n>   }\n> );\n>+\n>+// -----------------------------------------------------------------------------\n>+TestArray.addTest(\n>+  \"RSA-PSS key generation and sign/verify round-trip (SHA-256, 2048-bit)\",\n>+  function () {\n>+    var that = this;\n>+    var alg = {\n>+      name: \"RSA-PSS\",\n>+      hash: \"SHA-256\",\n>+      modulusLength: 2048,\n>+      publicExponent: new Uint8Array([0x01, 0x00, 0x01])\n>+    };\n>+\n>+    var privKey, pubKey, data = crypto.getRandomValues(new Uint8Array(128));\n>+    function setKey(x) { pubKey = x.publicKey; privKey = x.privateKey; }\n>+    function doSign() {\n>+      var alg = {name: \"RSA-PSS\", saltLength: 32};\n>+      return crypto.subtle.sign(alg, privKey, data);\n>+    }\n>+    function doVerify(x) {\n>+      var alg = {name: \"RSA-PSS\", saltLength: 32};\n>+      return crypto.subtle.verify(alg, pubKey, x, data);\n>+    }\n>+\n>+    crypto.subtle.generateKey(alg, false, [\"sign\", \"verify\"])\n>+      .then(setKey, error(that))\n>+      .then(doSign, error(that))\n>+      .then(doVerify, error(that))\n>+      .then(complete(that, x => x), error(that))\n>+  }\n>+);\n> /*]]>*/</script>\n> </head>\n> \n> <body>\n> \n> <div id=\"content\">\n> \t<div id=\"head\">\n> \t\t<b>Web</b>Crypto<br>\n>diff --git a/dom/webidl/SubtleCrypto.webidl b/dom/webidl/SubtleCrypto.webidl\n>index 9bb530e..dc0b744 100644\n>--- a/dom/webidl/SubtleCrypto.webidl\n>+++ b/dom/webidl/SubtleCrypto.webidl\n>@@ -61,16 +61,20 @@ dictionary RsaHashedKeyGenParams : Algorithm {\n>   required BigInteger publicExponent;\n>   required AlgorithmIdentifier hash;\n> };\n> \n> dictionary RsaOaepParams : Algorithm {\n>   CryptoOperationData label;\n> };\n> \n>+dictionary RsaPssParams : Algorithm {\n>+  [EnforceRange] required unsigned long saltLength;\n>+};\n>+\n> dictionary DhKeyGenParams : Algorithm {\n>   required BigInteger prime;\n>   required BigInteger generator;\n> };\n> \n> dictionary EcKeyGenParams : Algorithm {\n>   required NamedCurve namedCurve;\n> };\n>diff --git a/security/manager/ssl/ScopedNSSTypes.h b/security/manager/ssl/ScopedNSSTypes.h\n>index 7859a32..2b041b1 100644\n>--- a/security/manager/ssl/ScopedNSSTypes.h\n>+++ b/security/manager/ssl/ScopedNSSTypes.h\n>@@ -134,16 +134,19 @@ VFY_DestroyContext_true(VFYContext * ctx) {\n> } // namespace mozilla::psm\n> \n> MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLATE(ScopedPK11Context,\n>                                           PK11Context,\n>                                           mozilla::psm::PK11_DestroyContext_true)\n> MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLATE(ScopedSGNContext,\n>                                           SGNContext,\n>                                           mozilla::psm::SGN_DestroyContext_true)\n>+MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLATE(ScopedSGNDigestInfo,\n>+                                          SGNDigestInfo,\n>+                                          SGN_DestroyDigestInfo)\n> MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLATE(ScopedVFYContext,\n>                                           VFYContext,\n>                                           mozilla::psm::VFY_DestroyContext_true)\n> \n> /** A more convenient way of dealing with digests calculated into\n>  *  stack-allocated buffers. NSS must be initialized on the main thread before\n>  *  use, and the caller must ensure NSS isn't shut down, typically by\n>  *  subclassing nsNSSShutDownObject, while Digest is in use.\n>-- \n>2.6.3\n>", "author": "bugs@pettay.fi", "id": 10939306, "time": "2015-11-17T13:18:13Z"}, {"text": "Comment on attachment 8688416\n0002-Bug-1191936-Implement-RSA-PSS-signing-and-verificati.patch\n\nReview of attachment 8688416:\n-----------------------------------------------------------------\n\n::: dom/crypto/WebCryptoTask.cpp\n@@ +297,5 @@\n> +  }\n> +\n> +  return mech;\n> +}\n> +\n\nThis is duplicative with one of the other patches, yes?\n\n@@ +1074,4 @@\n>      , mSign(aSign)\n>      , mVerified(false)\n> +    , mIsRsaPkcs1(false)\n> +    , mIsRsaPss(false)\n\nFor this as well as the generateKey patch, I wonder if it would be better to just have an internal enum class instead of a bunch of flags.\n\n@@ +1222,5 @@\n> +    if (!sig) {\n> +      return NS_ERROR_DOM_OPERATION_ERR;\n> +    }\n> +\n> +    if (mSign) {\n\nYou've lost the necessary logic to do ECDSA signatures.  You need DSAU_DecodeDerSigToLen() after sign and DSAU_EncodeDerSigWithLen() before verify.  As it is, you should be failing the ECDSA tests.\n\n::: dom/crypto/test/test_WebCrypto_RSA_PSS.html\n@@ +70,5 @@\n> +      .then(doSign, error(that))\n> +      .then(doVerify, error(that))\n> +      .then(complete(that, x => x), error(that))\n> +  }\n> +);\n\nIt would be great to have a known-answer verify test.  Looks like there are some test vectors here:\n\nhttp://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-rsa-cryptography-standard.htm", "author": "rlb@ipv.sx", "id": 11008166, "time": "2015-12-15T20:14:06Z"}, {"text": "Comment on attachment 8688417\n0003-Bug-1191936-Implement-SPKI-PKCS-8-JWK-import-export-.patch\n\nReview of attachment 8688417:\n-----------------------------------------------------------------\n\n::: dom/crypto/test/test_WebCrypto_RSA_PSS.html\n@@ +209,5 @@\n> +TestArray.addTest(\n> +  \"RSA-PSS JWK export a public key\",\n> +  function () {\n> +    var that = this;\n> +    var alg = {name: \"RSA-PSS\", hash: \"SHA-1\"};\n\nGiven all the hating on SHA-1 lately, it would be nice to include a signature with SHA-256 and a 2048-bit key.", "author": "rlb@ipv.sx", "id": 11008182, "time": "2015-12-15T20:20:17Z"}, {"text": "\n> ::: dom/crypto/test/test_WebCrypto_RSA_PSS.html\n> @@ +70,5 @@\n> > +      .then(doSign, error(that))\n> > +      .then(doVerify, error(that))\n> > +      .then(complete(that, x => x), error(that))\n> > +  }\n> > +);\n> \n> It would be great to have a known-answer verify test.  Looks like there are\n> some test vectors here:\n> \n> http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-rsa-\n> cryptography-standard.htm\n\nAh, I see you're ahead of me here, and I was just looking at the wrong patch :)", "author": "rlb@ipv.sx", "id": 11008185, "time": "2015-12-15T20:21:02Z"}, {"text": "(In reply to Richard Barnes [:rbarnes] from comment #14)\n> ::: dom/crypto/WebCryptoTask.cpp\n> @@ +297,5 @@\n> > +  }\n> > +\n> > +  return mech;\n> > +}\n> > +\n> \n> This is duplicative with one of the other patches, yes?\n\nI don't understand this comment, is this code somewhere else already?\n\n> @@ +1074,4 @@\n> >      , mSign(aSign)\n> >      , mVerified(false)\n> > +    , mIsRsaPkcs1(false)\n> > +    , mIsRsaPss(false)\n> \n> For this as well as the generateKey patch, I wonder if it would be better to\n> just have an internal enum class instead of a bunch of flags.\n\nWill do. The generateKey patch wouldn't benefit much though, would it?\n\n> @@ +1222,5 @@\n> > +    if (!sig) {\n> > +      return NS_ERROR_DOM_OPERATION_ERR;\n> > +    }\n> > +\n> > +    if (mSign) {\n> \n> You've lost the necessary logic to do ECDSA signatures.  You need\n> DSAU_DecodeDerSigToLen() after sign and DSAU_EncodeDerSigWithLen() before\n> verify.  As it is, you should be failing the ECDSA tests.\n\nYeah, that seems true. ECDSA tests are passing... I'll investigate.\n\n(In reply to Richard Barnes [:rbarnes] from comment #15)\n> ::: dom/crypto/test/test_WebCrypto_RSA_PSS.html\n> @@ +209,5 @@\n> > +TestArray.addTest(\n> > +  \"RSA-PSS JWK export a public key\",\n> > +  function () {\n> > +    var that = this;\n> > +    var alg = {name: \"RSA-PSS\", hash: \"SHA-1\"};\n> \n> Given all the hating on SHA-1 lately, it would be nice to include a\n> signature with SHA-256 and a 2048-bit key.\n\nAt the top we generate/sign/verify with SHA-256 and a 2048-bit key. The \"official\" RSA test vectors don't include SHA-256 unfortunately.", "author": "ttaubert@mozilla.com", "id": 11088753, "time": "2016-01-19T20:08:42Z"}, {"text": "(In reply to Tim Taubert [:ttaubert] from comment #17)\n> (In reply to Richard Barnes [:rbarnes] from comment #14)\n> > @@ +1222,5 @@\n> > > +    if (!sig) {\n> > > +      return NS_ERROR_DOM_OPERATION_ERR;\n> > > +    }\n> > > +\n> > > +    if (mSign) {\n> > \n> > You've lost the necessary logic to do ECDSA signatures.  You need\n> > DSAU_DecodeDerSigToLen() after sign and DSAU_EncodeDerSigWithLen() before\n> > verify.  As it is, you should be failing the ECDSA tests.\n> \n> Yeah, that seems true. ECDSA tests are passing... I'll investigate.\n\nWe talked about this on IRC but here again for the record:\n\nThe current WebCrypto code calls DSAU_DecodeDerSigToLen() on the result of SEC_SignData() because we want to get rid of that encoding. It calls DSAU_EncodeDerSigWithLen() before passing the signature to VFY_VerifyData() because the API expects the same encoding it returns. The new APIs I'm using don't require this dance anymore.", "author": "ttaubert@mozilla.com", "id": 11088868, "time": "2016-01-19T20:41:02Z"}, {"text": "Created attachment 8709607\n0002-Bug-1191936-Implement-RSA-PSS-signing-and-verificati.patch, v2\n\nCarrying over r=smaug.", "author": "ttaubert@mozilla.com", "id": 11088891, "time": "2016-01-19T20:48:16Z"}, {"text": "Comment on attachment 8709607\n0002-Bug-1191936-Implement-RSA-PSS-signing-and-verificati.patch, v2\n\nReview of attachment 8709607:\n-----------------------------------------------------------------\n\nOverall, this looks good.  Just need a known-anwer test.\n\n::: dom/crypto/WebCryptoTask.cpp\n@@ +1166,5 @@\n>    bool mSign;\n>    bool mVerified;\n> +\n> +  // The signature algorithm to use.\n> +  enum class Algorithm: uint8_t { RSA_PKCS1, RSA_PSS, ECDSA};\n\nNit: Remove space before RSA_PKCS1.  Maybe alphabetize :)\n\nMight be useful to have an Unknown value here, that mAlgorithm is set to by default.  That might help avoid hard-to-debug errors later, in cases where mAlgorithm might accidentally not get initialized.  (\"Why does it think mAlgorithm is X?\")\n\n::: dom/crypto/test/test_WebCrypto_RSA_PSS.html\n@@ +43,5 @@\n>  );\n> +\n> +// -----------------------------------------------------------------------------\n> +TestArray.addTest(\n> +  \"RSA-PSS key generation and sign/verify round-trip (SHA-256, 2048-bit)\",\n\nThis test looks fine, but please add a known answer test, i.e., verifying a known-good signature.  ECDSA example here: \n\nhttps://dxr.mozilla.org/mozilla-central/source/dom/crypto/test/test_WebCrypto_ECDSA.html#166\n\nIt looks like the same file from which the OAEP tests were taken also has PSS tests.\n\nhttp://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-rsa-cryptography-standard.htm\n\n@@ +53,5 @@\n> +      modulusLength: 2048,\n> +      publicExponent: new Uint8Array([0x01, 0x00, 0x01])\n> +    };\n> +\n> +    var privKey, pubKey, data = crypto.getRandomValues(new Uint8Array(128));\n\nNit: Maybe I've been writing too much in languages with destructuring assignments, but it really looked to me like you were assigning all three values from one call :)  Maybe split this into \"var privKey, pubKey;\\nvar data = ...\"", "author": "rlb@ipv.sx", "id": 11092812, "time": "2016-01-20T20:53:39Z"}, {"text": "(In reply to Richard Barnes [:rbarnes] from comment #20)\n> ::: dom/crypto/WebCryptoTask.cpp\n> @@ +1166,5 @@\n> >    bool mSign;\n> >    bool mVerified;\n> > +\n> > +  // The signature algorithm to use.\n> > +  enum class Algorithm: uint8_t { RSA_PKCS1, RSA_PSS, ECDSA};\n> \n> Nit: Remove space before RSA_PKCS1.  Maybe alphabetize :)\n> \n> Might be useful to have an Unknown value here, that mAlgorithm is set to by\n> default.  That might help avoid hard-to-debug errors later, in cases where\n> mAlgorithm might accidentally not get initialized.  (\"Why does it think\n> mAlgorithm is X?\")\n\nDone, with assertion.\n\n> ::: dom/crypto/test/test_WebCrypto_RSA_PSS.html\n> > +// -----------------------------------------------------------------------------\n> > +TestArray.addTest(\n> > +  \"RSA-PSS key generation and sign/verify round-trip (SHA-256, 2048-bit)\",\n> \n> This test looks fine, but please add a known answer test, i.e., verifying a\n> known-good signature.\n\nWe have that already in part 3. Will consolidate the tests in a separate patch next time.\n\n> @@ +53,5 @@\n> > +      modulusLength: 2048,\n> > +      publicExponent: new Uint8Array([0x01, 0x00, 0x01])\n> > +    };\n> > +\n> > +    var privKey, pubKey, data = crypto.getRandomValues(new Uint8Array(128));\n> \n> Nit: Maybe I've been writing too much in languages with destructuring\n> assignments, but it really looked to me like you were assigning all three\n> values from one call :)  Maybe split this into \"var privKey, pubKey;\\nvar\n> data = ...\"\n\nDone.", "author": "ttaubert@mozilla.com", "id": 11099076, "time": "2016-01-22T14:39:24Z"}, {"text": "Created attachment 8711000\n0002-Bug-1191936-Implement-RSA-PSS-signing-and-verificati.patch, v3", "author": "ttaubert@mozilla.com", "id": 11099078, "time": "2016-01-22T14:39:46Z"}, {"text": "Created attachment 8711021\n0004-Bug-1191936-Add-more-test-vectors-and-a-test-for-det.patch\n\nAdded a few more test vectors for SHA-2 hash/mask functions and a test to ensure that invalid signatures fail. Added a test for deterministic signatures with saltLength=0.", "author": "ttaubert@mozilla.com", "id": 11099219, "time": "2016-01-22T15:18:12Z"}, {"text": "Comment on attachment 8711021\n0004-Bug-1191936-Add-more-test-vectors-and-a-test-for-det.patch\n\nReview of attachment 8711021:\n-----------------------------------------------------------------\n\n::: dom/crypto/test/test_WebCrypto_RSA_PSS.html\n@@ +214,5 @@\n> +    crypto.subtle.importKey(\"spki\", vec.spki, alg, false, [\"verify\"])\n> +      .then(doVerify, error(that))\n> +      .then(complete(that, x => x), error(that));\n> +  }\n> +);\n\nIt seems like you could probably collapse this into a single test, like you did with the negative tests above.  Just define a verifyCase() method that does import.then(verify), then wrap them all with Promise.all().every().  But I can live with it as-is.", "author": "rlb@ipv.sx", "id": 11101691, "time": "2016-01-23T15:59:03Z"}, {"text": "(In reply to Richard Barnes [:rbarnes] from comment #24)\n> It seems like you could probably collapse this into a single test, like you\n> did with the negative tests above.  Just define a verifyCase() method that\n> does import.then(verify), then wrap them all with Promise.all().every(). \n> But I can live with it as-is.\n\nDone.", "author": "ttaubert@mozilla.com", "id": 11108647, "time": "2016-01-26T15:09:58Z"}, {"text": "https://hg.mozilla.org/integration/mozilla-inbound/rev/1faac7557b25\nhttps://hg.mozilla.org/integration/mozilla-inbound/rev/1fba432e1cab\nhttps://hg.mozilla.org/integration/mozilla-inbound/rev/29a076e8bc0d\nhttps://hg.mozilla.org/integration/mozilla-inbound/rev/92e279613f0e", "author": "pulsebot@bots.tld", "id": 11110017, "time": "2016-01-26T20:31:45Z"}, {"text": "https://hg.mozilla.org/mozilla-central/rev/1faac7557b25\nhttps://hg.mozilla.org/mozilla-central/rev/1fba432e1cab\nhttps://hg.mozilla.org/mozilla-central/rev/29a076e8bc0d\nhttps://hg.mozilla.org/mozilla-central/rev/92e279613f0e", "author": "cbook@mozilla.com", "id": 11111820, "time": "2016-01-27T11:10:05Z"}, {"text": "Release Note Request (optional, but appreciated)\n[Why is this notable]: I think devs might want to know they can now use RSA-PSS in WebCrypto with Firefox.\n[Suggested wording]: WebCrypto: RSA-PSS signature support\n[Links (documentation, blog post, etc)]:", "author": "ttaubert@mozilla.com", "id": 11120525, "time": "2016-01-29T17:34:06Z"}, {"text": "Added to Fx 47 (Aurora) release notes", "author": "rkothari@mozilla.com", "id": 11224611, "time": "2016-03-07T18:05:26Z"}, {"text": "Thank Tim for the fix. My RSA-PSS code that works with Chrome now also works with Firefox 47 Nightly.\n\nThank Ritu for adding the release notes. There may be a trivial issue though: The bug reference on https://developer.mozilla.org/en-US/Firefox/Releases/47 is missing the closing bracket.", "author": "FranklinWhale@hotmail.com", "id": 11234042, "time": "2016-03-10T01:03:40Z"}], "id": 1191936, "priority": "--", "cc": ["bgallia@gmail.com", "bugs@pettay.fi", "gijskruitbosch+bugs@gmail.com", "jypenator@gmail.com", "maier1michael@gmail.com", "mcastelluccio@mozilla.com", "rkothari@mozilla.com", "rlb@ipv.sx", "ttaubert@mozilla.com"], "cf_crash_signature": "", "version": "Trunk", "cf_qa_whiteboard": "", "cf_tracking_firefox_esr52": "---", "see_also": [], "cf_tracking_thunderbird_esr60": "---", "cf_platform_rel": "---", "product": "Core", "cf_fx_iteration": "---", "blocks": [], "qa_contact": "", "creation_time": "2015-08-06T18:23:03Z", "cf_status_firefox_esr52": "---", "component": "DOM: Security", "assigned_to_detail": {"email": "ttaubert@mozilla.com", "id": 402526, "name": "ttaubert@mozilla.com", "real_name": "Tim Taubert [:ttaubert] (inactive)"}, "cf_tracking_firefox_esr60": "---", "cf_status_firefox62": "---", "cf_status_firefox61": "---", "cf_status_firefox60": "---", "target_milestone": "mozilla47", "cf_rank": null, "cf_status_firefox47": "fixed", "severity": "normal", "groups": [], "cf_status_thunderbird_esr52": "---", "url": "", "cf_status_thunderbird_esr60": "---", "creator_detail": {"email": "FranklinWhale@hotmail.com", "id": 272073, "name": "FranklinWhale@hotmail.com", "real_name": "Franklin Tse"}, "whiteboard": "", "mentors": [], "summary": "Implement RSA-PSS in WebCrypto API", "cf_has_str": "---", "alias": null, "dupe_of": null, "flags": [], "last_change_time": "2018-06-03T00:14:24Z", "assigned_to": "ttaubert@mozilla.com", "is_open": false, "history": [{"changes": [{"removed": "", "field_name": "cc", "added": "bgallia@gmail.com"}], "who": "bgallia@gmail.com", "when": "2015-10-06T22:59:01Z"}, {"changes": [{"removed": "UNCONFIRMED", "field_name": "status", "added": "NEW"}, {"removed": "", "field_name": "cc", "added": "ttaubert@mozilla.com"}, {"removed": "0", "field_name": "is_confirmed", "added": "1"}], "who": "ttaubert@mozilla.com", "when": "2015-10-07T05:22:09Z"}, {"changes": [{"removed": "", "field_name": "depends_on", "added": "158750"}], "who": "ttaubert@mozilla.com", "when": "2015-10-07T05:23:07Z"}, {"changes": [{"removed": "", "field_name": "keywords", "added": "dev-doc-needed"}, {"removed": "", "field_name": "cc", "added": "jypenator@gmail.com"}], "who": "jypenator@gmail.com", "when": "2015-10-07T06:12:23Z"}, {"changes": [{"removed": "", "field_name": "cc", "added": "gijskruitbosch+bugs@gmail.com"}], "who": "gijskruitbosch+bugs@gmail.com", "when": "2015-10-07T11:14:22Z"}, {"changes": [{"removed": "NEW", "field_name": "status", "added": "ASSIGNED"}, {"removed": "nobody@mozilla.org", "field_name": "assigned_to", "added": "ttaubert@mozilla.com"}], "who": "ttaubert@mozilla.com", "when": "2015-10-13T19:39:54Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8673557, "added": "1"}], "who": "ttaubert@mozilla.com", "when": "2015-10-14T18:04:59Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8673558, "added": "1"}], "who": "ttaubert@mozilla.com", "when": "2015-10-14T18:05:30Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8673811, "added": "1"}, {"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8673845, "added": "1"}], "who": "ttaubert@mozilla.com", "when": "2015-10-14T20:10:33Z"}, {"changes": [{"removed": "158750", "field_name": "depends_on", "added": "1215295"}], "who": "ttaubert@mozilla.com", "when": "2015-10-15T21:15:49Z"}, {"changes": [{"removed": "", "field_name": "cc", "added": "maier1michael@gmail.com"}], "who": "maier1michael@gmail.com", "when": "2015-10-30T17:01:20Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8673808, "added": "1"}, {"removed": "", "field_name": "cc", "added": "rlb@ipv.sx"}, {"field_name": "flagtypes.name", "removed": "", "attachment_id": 8688415, "added": "review?(rlb@ipv.sx)"}], "who": "ttaubert@mozilla.com", "when": "2015-11-17T11:40:47Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8673810, "added": "1"}, {"field_name": "flagtypes.name", "removed": "", "attachment_id": 8688416, "added": "review?(rlb@ipv.sx)"}], "who": "ttaubert@mozilla.com", "when": "2015-11-17T11:41:09Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8673864, "added": "1"}, {"field_name": "flagtypes.name", "removed": "", "attachment_id": 8688417, "added": "review?(rlb@ipv.sx)"}], "who": "ttaubert@mozilla.com", "when": "2015-11-17T11:41:36Z"}, {"changes": [{"removed": "", "field_name": "cc", "added": "bugs@pettay.fi"}, {"field_name": "flagtypes.name", "removed": "", "attachment_id": 8688416, "added": "review?(bugs@pettay.fi)"}], "who": "ttaubert@mozilla.com", "when": "2015-11-17T11:42:32Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(bugs@pettay.fi)", "attachment_id": 8688416, "added": "review+"}], "who": "bugs@pettay.fi", "when": "2015-11-17T13:18:13Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(rlb@ipv.sx)", "attachment_id": 8688415, "added": "review+"}], "who": "rlb@ipv.sx", "when": "2015-12-15T17:44:01Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(rlb@ipv.sx)", "attachment_id": 8688416, "added": "review-"}], "who": "rlb@ipv.sx", "when": "2015-12-15T20:14:06Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(rlb@ipv.sx)", "attachment_id": 8688417, "added": "review+"}], "who": "rlb@ipv.sx", "when": "2015-12-15T20:20:17Z"}, {"changes": [{"removed": "", "field_name": "depends_on", "added": "1228410"}], "who": "ttaubert@mozilla.com", "when": "2016-01-19T11:58:03Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8688416, "added": "1"}, {"field_name": "flagtypes.name", "removed": "", "attachment_id": 8709607, "added": "review?(rlb@ipv.sx)"}], "who": "ttaubert@mozilla.com", "when": "2016-01-19T20:48:16Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(rlb@ipv.sx)", "attachment_id": 8709607, "added": "review-"}], "who": "rlb@ipv.sx", "when": "2016-01-20T20:53:39Z"}, {"changes": [{"field_name": "attachments.isobsolete", "removed": "0", "attachment_id": 8709607, "added": "1"}, {"field_name": "flagtypes.name", "removed": "", "attachment_id": 8711000, "added": "review?(rlb@ipv.sx)"}], "who": "ttaubert@mozilla.com", "when": "2016-01-22T14:39:46Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "", "attachment_id": 8711021, "added": "review?(rlb@ipv.sx)"}], "who": "ttaubert@mozilla.com", "when": "2016-01-22T15:18:12Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(rlb@ipv.sx)", "attachment_id": 8711000, "added": "review+"}], "who": "rlb@ipv.sx", "when": "2016-01-22T21:27:16Z"}, {"changes": [{"field_name": "flagtypes.name", "removed": "review?(rlb@ipv.sx)", "attachment_id": 8711021, "added": "review+"}], "who": "rlb@ipv.sx", "when": "2016-01-23T15:59:03Z"}, {"changes": [{"removed": "ASSIGNED", "field_name": "status", "added": "RESOLVED"}, {"removed": "", "field_name": "resolution", "added": "FIXED"}, {"removed": "---", "field_name": "target_milestone", "added": "mozilla47"}, {"removed": "", "field_name": "cf_last_resolved", "added": "2016-01-27 03:10:05"}, {"removed": "---", "field_name": "cf_status_firefox47", "added": "fixed"}], "who": "cbook@mozilla.com", "when": "2016-01-27T11:10:05Z"}, {"changes": [{"removed": "---", "field_name": "cf_tracking_firefox_relnote", "added": "?"}], "who": "ttaubert@mozilla.com", "when": "2016-01-29T17:34:06Z"}, {"changes": [{"removed": "", "field_name": "cc", "added": "rkothari@mozilla.com"}, {"removed": "?", "field_name": "cf_tracking_firefox_relnote", "added": "47+"}], "who": "rkothari@mozilla.com", "when": "2016-03-07T18:05:26Z"}, {"changes": [{"removed": "", "field_name": "keywords", "added": "feature"}, {"removed": "", "field_name": "cc", "added": "mcastelluccio@mozilla.com"}], "who": "mcastelluccio@mozilla.com", "when": "2018-06-03T00:14:24Z"}], "resolution": "FIXED", "op_sys": "Unspecified", "cf_fx_points": "---", "cf_blocking_fennec": "---"}